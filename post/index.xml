<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on breml&#39;s blog</title>
    <link>https://breml.github.io/post/</link>
    <description>Recent content in Posts on breml&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://breml.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using MongoDB Backend Service with Go App in the Swisscom App Cloud</title>
      <link>https://breml.github.io/blog/2015/12/22/using-mongodb-backend-service-with-go-app-in-the-swisscom-app-cloud/</link>
      <pubDate>Tue, 22 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/12/22/using-mongodb-backend-service-with-go-app-in-the-swisscom-app-cloud/</guid>
      <description>

&lt;h2 id=&#34;introduction:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In my &lt;a href=&#34;https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/&#34;&gt;last post&lt;/a&gt; I described how to create and deploy an app, written with the Google &lt;a href=&#34;https://golang.org&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt; language, to the &lt;a href=&#34;http://developer.swisscom.com/&#34; target=&#34;_blank&#34;&gt;Swisscom Application Cloud&lt;/a&gt;. This post is a follow up, in which I would like to share some of the learnings, I discovered while extending the &lt;a href=&#34;https://github.com/breml/appcloud/tree/helloworld&#34; target=&#34;_blank&#34;&gt;Hello World&lt;/a&gt; app, following the ideas for the &lt;a href=&#34;https://ict.swisscom.ch/2015/12/move-with-your-mongodb-node-js-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;node.js example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This blog post is not a detailed step by step tutorial, but rather points out the in my opinion important steps to understand how to get a Go app running in the App Cloud with a MongoDB backend. I strongly suggest to read the above linked blog posts as well, as they help to get a better overall understanding.&lt;br /&gt;
The full working example could be found in my &lt;a href=&#34;https://github.com/breml/appcloud&#34; target=&#34;_blank&#34;&gt;Github repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Like in my last post, the described steps assume to be executed on a Linux system, precisely on &lt;a href=&#34;http://www.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;add-mongodb-as-backend-to-the-app:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Add MongoDB as Backend to the App&lt;/h2&gt;

&lt;p&gt;To be able to locally test the extended version of our app you need a &lt;a href=&#34;https://www.mongodb.org/&#34; target=&#34;_blank&#34;&gt;MongoDB&lt;/a&gt; installation. On most Linux distributions MongoDB might be installed from the respective repository with the packet manager of choice. In my case, a simple&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install mongodb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;does the job. This installs version 2.4.9 of MongoDB. As I found out later, the MongoDB version in use in the Swisscom App Cloud is 3.0.6 (as of writing). Unfortunately the MongoDB client with version 2.4.9 is not compatible with server version 3.0.6, especially if authentication is used. More on this topic later.&lt;/p&gt;

&lt;p&gt;On Ubuntu the MongoDB daemon gets started automatically after installation. On other Linux distributions, this may require a manual start.&lt;/p&gt;

&lt;h2 id=&#34;connect-a-go-app-to-mongodb:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Connect a Go App to MongoDB&lt;/h2&gt;

&lt;p&gt;As MongoDB driver package I have chosen &lt;a href=&#34;https://gopkg.in/mgo.v2&#34; target=&#34;_blank&#34;&gt;gopkg.in/mgo.v2&lt;/a&gt; which you may get with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get gopkg.in/mgo.v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On &lt;a href=&#34;https://godoc.org/gopkg.in/mgo.v2&#34; target=&#34;_blank&#34;&gt;godoc.org&lt;/a&gt; you find the documentation of the &lt;em&gt;mgo.v2&lt;/em&gt; package. The main parts for the usage in our app are the following (only relevant sections, find the complete project on &lt;a href=&#34;https://github.com/breml/appcloud&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Insert a new value (while deleting the old):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;session, err := mgo.Dial(&amp;quot;mongodb://localhost:27017/weatherDB&amp;quot;)
if err != nil {
	log.Printf(&amp;quot;MongoDB dial err %v\n&amp;quot;, err)
}
defer session.Close()

c := session.DB(&amp;quot;weatherDB&amp;quot;).C(&amp;quot;weatherCOLL&amp;quot;)

err = c.DropCollection()
if err != nil {
	log.Printf(&amp;quot;MongoDB drop collection err %v\n&amp;quot;, err)
}

err = c.Insert(Temperature{Temperature: temperature})
if err != nil {
	log.Printf(&amp;quot;MongoDB insert err %v\n&amp;quot;, err)
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And querying the saved value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;session, err := mgo.Dial(&amp;quot;mongodb://localhost:27017/weatherDB&amp;quot;)
if err != nil {
	log.Printf(&amp;quot;MongoDB dial err %v\n&amp;quot;, err)
}
defer session.Close()

c := session.DB(&amp;quot;weatherDB&amp;quot;).C(&amp;quot;weatherCOLL&amp;quot;)

var result Temperature

err = c.Find(nil).One(&amp;amp;result)
if err != nil {
	log.Printf(&amp;quot;MongoDB find err %v\n&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;preparing-the-app-for-the-cloud:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Preparing the App for the Cloud&lt;/h2&gt;

&lt;p&gt;As you already know from the previous post, in the App Cloud the configuration (e. g. port to bind, connection details for the backend services) are provided by environment variables. In the &amp;ldquo;Hello World&amp;rdquo; example from the first post, the only information, we needed to get from the environment was the port to bind. In this example we used the &lt;em&gt;os&lt;/em&gt; package from the Go standard library to get the environment variable. The connection details for the MongoDB instance in the App Cloud will also be provided as environment variable, where the value is a &lt;a href=&#34;http://json.org&#34; target=&#34;_blank&#34;&gt;JSON&lt;/a&gt; document. It would be possible to parse this JSON document with the &lt;em&gt;encoding/json&lt;/em&gt; package from the Go standard library, but luckily there is even an easier solution. Cloud Foundry provides the &lt;a href=&#34;https://github.com/cloudfoundry-community/go-cfenv&#34; target=&#34;_blank&#34;&gt;go-cfenv&lt;/a&gt; (&lt;a href=&#34;https://godoc.org/github.com/cloudfoundry-community/go-cfenv&#34; target=&#34;_blank&#34;&gt;godoc.org&lt;/a&gt;) Go package, which&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;&amp;hellip; provides information about the current app deployed on Cloud Foundry, including any bound service(s).&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is exactly what we need. Get the package as usual with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/cloudfoundry-community/go-cfenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the main function of our Go program we add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Get settings from ENV if present (e. g. if in App Cloud)
appEnv, err := cfenv.Current()
if err == nil {
	// Port to bind web app
	port = strconv.Itoa(appEnv.Port)

	name = appEnv.Name
	log.SetPrefix(name + prefixDelim)

	// MongoDB Service
	mgoService, err := appEnv.Services.WithName(&amp;quot;mongodb&amp;quot;)
	if err == nil {
		var ok bool
		mongouri, ok = mgoService.Credentials[&amp;quot;uri&amp;quot;].(string)
		if !ok {
			log.Fatalf(&amp;quot;No valid MongoDB uri\n&amp;quot;)
		}
		mongodb, ok = mgoService.Credentials[&amp;quot;database&amp;quot;].(string)
		if !ok {
			log.Fatalf(&amp;quot;No valid MongoDB database\n&amp;quot;)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snipped processes all the relevant environment variables and puts them in Go structs, where we can access them easily.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-mongodb-service:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Adding a MongoDB Service&lt;/h2&gt;

&lt;p&gt;The steps, required to add MongoDB service to your App Cloud space are quite easy. You have the possibility to add the service in the &lt;a href=&#34;https://console.developer.swisscom.com/&#34; target=&#34;_blank&#34;&gt;Developer Console&lt;/a&gt; or you may use the command line. This assumes you already installed the &lt;a href=&#34;ttps://github.com/cloudfoundry/cli/&#34; target=&#34;_blank&#34;&gt;Cloud Foundry CLI&lt;/a&gt; tools and you logged in to the App Cloud with the CLI tools (see previous blog post).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf create-service mongodb small mongodb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your app is already existing in the App Cloud, for example by pushing the &amp;ldquo;Hello World&amp;rdquo; example, you may now bind the MongoDB service to your app:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf bind-service DemoApp mongodb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-our-go-dependencies-with-godep:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Update our Go Dependencies with Godep&lt;/h2&gt;

&lt;p&gt;Before we can push our updated app to the App Cloud, we have to update our dependencies with the &lt;em&gt;godep&lt;/em&gt; tool, by running:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;godep save -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will place the newly introduced Go packages (&lt;em&gt;gopkg.in/mgo.v2&lt;/em&gt; and &lt;em&gt;github.com/cloudfoundry-community/go-cfenv&lt;/em&gt;) including their dependencies into the &lt;code&gt;Godeps&lt;/code&gt; folder and update the import statements accordingly.&lt;/p&gt;

&lt;h2 id=&#34;push-the-updated-app-to-the-cloud:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Push the Updated App to the Cloud&lt;/h2&gt;

&lt;p&gt;With the MongoDB service created, the binding between app and MongoDB service in place, the app prepared to read the configuration from the environment variables and our Go package dependencies updated, we are ready to push our updated app to the cloud by simply executing &lt;code&gt;cf push&lt;/code&gt;. You may now access the updated app with your browser and enjoy playing with the weather.&lt;/p&gt;

&lt;h2 id=&#34;directly-connect-to-mongodb-service-in-the-app-cloud:0e124371b869ebbf7d75881dc4fcca46&#34;&gt;Directly Connect to MongoDB Service in the App Cloud&lt;/h2&gt;

&lt;p&gt;The Swisscom App Cloud allows to setup a &amp;ldquo;network tunnel&amp;rdquo; from your local machine to the backend services in the App Cloud. This requires the &lt;em&gt;Service Connector&lt;/em&gt; plugin for the Cloud Foundry CLI tools. The installation is simple, to get the Linux 64 bit version of the plugin just execute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf install-plugin https://swisscom-plugin.scapp.io/linux64/swisscom-plugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list of the available pre-built plugins for the different platforms (Windows, OSX, 32 or 64 bit) is available in the chapter &lt;a href=&#34;https://docs.developer.swisscom.com/services/services/managing-services.html#installation-service-connector&#34; target=&#34;_blank&#34;&gt;Managing Services&lt;/a&gt; in the App Cloud documentation.&lt;/p&gt;

&lt;p&gt;Before we can open the network tunnel to the App Cloud, we have to create a so called service key on the respective service. This may be done with the following command, where &amp;ldquo;local&amp;rdquo; is the name of the newly created service key:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf create-service-key mongodb local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the just created service key credentials execute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf service-key mongodb local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above command prints something similar to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;{
 &amp;quot;database&amp;quot;: &amp;quot;mxAa4xiVidUHrO48&amp;quot;,
 &amp;quot;database_uri&amp;quot;: &amp;quot;mongodb://PJq5jZbdp6Bqshmn:FSCEvxfMPgd62Q1Z@uncvb9blaeo7t3mw.service.consul:59629/mxAa4xiVidUHrO48&amp;quot;,
 &amp;quot;host&amp;quot;: &amp;quot;uncvb9blaeo7t3mw.service.consul&amp;quot;,
 &amp;quot;password&amp;quot;: &amp;quot;FSCEvxfMPgd62Q1Z&amp;quot;,
 &amp;quot;port&amp;quot;: &amp;quot;59629&amp;quot;,
 &amp;quot;uri&amp;quot;: &amp;quot;mongodb://PJq5jZbdp6Bqshmn:FSCEvxfMPgd62Q1Z@uncvb9blaeo7t3mw.service.consul:59629/mxAa4xiVidUHrO48&amp;quot;,
 &amp;quot;username&amp;quot;: &amp;quot;PJq5jZbdp6Bqshmn&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the credentials at hand, we may now setup the network tunnel by executing (replace [host] and [port] according to the generated credentials in the service key):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;cf service-connector 13000 [host]:[port]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above command will not exit until receiving SIGINT, normally sent by &lt;code&gt;Ctrl+C&lt;/code&gt;. While running, it will listen on the provided port, in the above example port 13000. We now can connect with our local MongoDB client to this local port, which will forward our connection to the MongoDB instance in the App Cloud (replace [username], [database] and [password] according to the generated credentials in the service key):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;mongo -username [username] -host localhost -port 13000 [database] -password [password]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The password may be omitted in the above command, in this case the password will be prompted, which prevents from leaking sensitive information to the process list or the shell history.&lt;/p&gt;

&lt;p&gt;As mentioned in the section about the MongoDB installation, the above command didn&amp;rsquo;t work for me in the first place. It always throwed the following error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;MongoDB shell version: 2.4.9
connecting to: localhost:13000/mxAa4xiVidUHrO48
Mon Dec 21 22:06:39.495 Error: 18 { ok: 0.0, errmsg: &amp;quot;auth failed&amp;quot;, code: 18 } at src/mongo/shell/db.js:228
exception: login failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This error message didn&amp;rsquo;t disappear until I updated my local MongoDB installation to a more recent version. For this update I followed the instructions in the &lt;a href=&#34;https://docs.mongodb.org/v3.0/tutorial/install-mongodb-on-ubuntu/&#34; target=&#34;_blank&#34;&gt;Install MongoDB on Ubuntu tutorial&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploy a Go Web App to the Swisscom Application Cloud</title>
      <link>https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/</link>
      <pubDate>Thu, 17 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/</guid>
      <description>

&lt;p&gt;Inspired by the &lt;a href=&#34;https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;this blog post&lt;/a&gt; about the deployment of a &lt;a href=&#34;https://nodejs.org&#34; target=&#34;_blank&#34;&gt;node.js&lt;/a&gt; example app to the &lt;a href=&#34;http://developer.swisscom.com/&#34; target=&#34;_blank&#34;&gt;Swisscom Application Cloud&lt;/a&gt;, I decided to test the Swisscom Application Cloud my self with a similar app, written in Google &lt;a href=&#34;https://golang.org&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt; language.&lt;/p&gt;

&lt;p&gt;This blog should take you through the essential steps on a Linux based system to push your own Go based app to a &lt;a href=&#34;https://www.cloudfoundry.org&#34; target=&#34;_blank&#34;&gt;Cloud Foundry&lt;/a&gt; based app cloud, for example the one from Swisscom.&lt;/p&gt;

&lt;h2 id=&#34;preparations:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Preparations&lt;/h2&gt;

&lt;h3 id=&#34;go-development-environment:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Go development environment&lt;/h3&gt;

&lt;p&gt;I assume you already have a prepared Go development environment. Otherwise I suggest you to start with the &lt;a href=&#34;https://golang.org/doc/install&#34; target=&#34;_blank&#34;&gt;Getting Started&lt;/a&gt; manual.&lt;/p&gt;

&lt;p&gt;To check, if you have the go tool chain ready, just enter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this should print something like the below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOARCH=&amp;quot;amd64&amp;quot;
GOBIN=&amp;quot;&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;quot;amd64&amp;quot;
GOHOSTOS=&amp;quot;linux&amp;quot;
GOOS=&amp;quot;linux&amp;quot;
GOPATH=&amp;quot;/home/user/go&amp;quot;
GORACE=&amp;quot;&amp;quot;
GOROOT=&amp;quot;/usr/local/go&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_amd64&amp;quot;
GO15VENDOREXPERIMENT=&amp;quot;0&amp;quot;
CC=&amp;quot;gcc&amp;quot;
GOGCCFLAGS=&amp;quot;-g -O2 -fPIC -m64 -pthread&amp;quot;
CXX=&amp;quot;g++&amp;quot;
CGO_ENABLED=&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are using Go in version 1.5.x, you may have set the environment variable &lt;code&gt;GO15VENDOREXPERIMENT=1&lt;/code&gt;. For this tutorial I suggest to switch the Go 1.5 vendor experiment off (&lt;code&gt;GO15VENDOREXPERIMENT=0&lt;/code&gt;), as this makes our deployment to the app cloud a little bit easier. (Additional information about the hitches with &lt;em&gt;godep&lt;/em&gt; and the Go 1.5 vendor experiment could be found in this &lt;a href=&#34;https://devcenter.heroku.com/articles/go-support#go-1-5-vendor-experiment&#34; target=&#34;_blank&#34;&gt;article on heroku&lt;/a&gt;.)&lt;/p&gt;

&lt;h3 id=&#34;godep:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Godep&lt;/h3&gt;

&lt;p&gt;Cloud Foundry uses so called &lt;a href=&#34;https://docs.developer.swisscom.com/apps/deploy-apps/index.html#buildpacks&#34; target=&#34;_blank&#34;&gt;buildpacks&lt;/a&gt; to provide framework and runtime support for the application. We will later use the &lt;a href=&#34;https://github.com/cloudfoundry/go-buildpack&#34; target=&#34;_blank&#34;&gt;Go buildpack&lt;/a&gt; to deploy our web app to the app cloud.&lt;/p&gt;

&lt;p&gt;In order to specify the external dependencies (external Go packages) for the Go web app, the above mentioned buildpack uses the tool &lt;a href=&#34;https://github.com/tools/godep&#34; target=&#34;_blank&#34;&gt;Godep&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The installation of Godep is quite straight forward. Just let Go do the work for us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/tools/godep
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will place the &lt;code&gt;godep&lt;/code&gt; command in the directory &lt;code&gt;$GOPATH/bin&lt;/code&gt;. If &lt;code&gt;$GOPATH/bin&lt;/code&gt; is part of your &lt;code&gt;$PATH&lt;/code&gt;, &lt;em&gt;godep&lt;/em&gt; is now directly available as command.&lt;/p&gt;

&lt;h3 id=&#34;cloud-foundry-cli:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Cloud Foundry CLI&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/cloudfoundry/cli/&#34; target=&#34;_blank&#34;&gt;Cloud Foundry Command Line Interface (CF CLI)&lt;/a&gt; is a command line tool for deploying and managing your applications within the app cloud. You can download the CF CLI from &lt;a href=&#34;https://github.com/cloudfoundry/cli/releases/&#34; target=&#34;_blank&#34;&gt;github.com/cloudfoundry/cli/releases&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The CF CLI tool is written in Go as well and therefore consists of a single static binary. The installation is as simple as download and decompress the executable. For a 64 bit Linux systems, you could use the following commands to download the latest version (6.14.0 as of writing) and to place the executable to the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -L &#39;https://cli.run.pivotal.io/stable?release=linux64-binary&amp;amp;version=6.14.0&amp;amp;source=github-rel&#39; | tar -xz &amp;gt; cf; chmod +x cf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check if everything is working, execute &lt;code&gt;./cf help&lt;/code&gt;. For best comfort, you should move the &lt;code&gt;cf&lt;/code&gt; binary to a directory within you &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Alternatively there are installable packages for several OS available as well.&lt;/p&gt;

&lt;h2 id=&#34;create-the-go-hello-world-web-app:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Create the Go &amp;ldquo;Hello world&amp;rdquo; Web App&lt;/h2&gt;

&lt;p&gt;Now we have everything in place to get started with writing the Go version of the &amp;ldquo;Hello world&amp;rdquo; web app.&lt;/p&gt;

&lt;p&gt;First you should create a new directory named &lt;em&gt;appcloud&lt;/em&gt; within &lt;code&gt;$GOPATH/src&lt;/code&gt; and enter it. If you are a &lt;a href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;github.com&lt;/a&gt; user, a good choice would be &lt;code&gt;$GOPATH/src/github.com/&amp;lt;your github username&amp;gt;/appcloud&lt;/code&gt;. Secondly create a new file named &lt;em&gt;main.go&lt;/em&gt; with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;Hello world!&amp;quot;)
}

func main() {
	port := os.Getenv(&amp;quot;PORT&amp;quot;)
	if port == &amp;quot;&amp;quot; {
		port = &amp;quot;3000&amp;quot;
	}

	log.Printf(&amp;quot;Use port: %s\n&amp;quot;, port)

	http.HandleFunc(&amp;quot;/&amp;quot;, helloHandler)
	err := http.ListenAndServe(&amp;quot;:&amp;quot;+port, nil)
	if err != nil {
		log.Panicf(&amp;quot;ListenAndServe error: %v\n&amp;quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program is quite straight forward:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We name the package &amp;ldquo;main&amp;rdquo;, because in Go the &lt;em&gt;main&lt;/em&gt; package is the entry point for the application.&lt;/li&gt;
&lt;li&gt;We import some additional packages from the fantastic Go standard library, which will allow us to listen and answer to web requests.&lt;/li&gt;
&lt;li&gt;The function &lt;code&gt;helloHandler&lt;/code&gt; will be executed for every request to the web app and will write the famous &amp;ldquo;Hello world&amp;rdquo; to the &lt;code&gt;http.ResponseWriter&lt;/code&gt;, which will be returned to the browser of the client.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;main&lt;/code&gt; function is where our program starts and where we do some setup:

&lt;ul&gt;
&lt;li&gt;First we collect the TCP Port to bind from the environment variable &lt;code&gt;PORT&lt;/code&gt;, because this variable will be set in the app cloud the tell our web app on which TCP port we should bind. If no such environment variable is present, we default to port &lt;em&gt;3000&lt;/em&gt;. (Side note: Go expects the port to be a string, because values like &lt;code&gt;http&lt;/code&gt; as alias for port 80, are understood by Go as well)&lt;/li&gt;
&lt;li&gt;For convenience we log (defaults to stderr) the TCP port, where the web app will bind.&lt;/li&gt;
&lt;li&gt;With &lt;code&gt;http.HandleFunc(&amp;quot;/&amp;quot;, helloHandler)&lt;/code&gt; we add the function &lt;code&gt;helloHandler&lt;/code&gt; as handler function to our web server. Because this is the only handler function and we set the pattern to &lt;code&gt;/&lt;/code&gt;, every request to our web app will execute the helloHandler.&lt;/li&gt;
&lt;li&gt;The whole &amp;ldquo;start a web server&amp;rdquo; magic happens in the line &lt;code&gt;err := http.ListenAndServe(&amp;quot;:&amp;quot;+port, nil)&lt;/code&gt;. With this line our program starts an endless loop to listen on the respective TCP port, on all available IP addresses, and to execute the defined handler functions (in our case there is just one).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s it for the web app. Now let&amp;rsquo;s have a look, if every thing is working properly.&lt;/p&gt;

&lt;p&gt;We can start our web app with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go run main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just after starting you should see an output similar to the one below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;2015/12/17 10:58:38 Use port: 3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If no other output is printed out, the program is ready to serve HTTP requests. So point your web browser to &lt;a href=&#34;http://localhost:3000&#34; target=&#34;_blank&#34;&gt;http://localhost:3000&lt;/a&gt; and enjoy the &amp;ldquo;Hello world!&amp;rdquo; output.&lt;/p&gt;

&lt;h2 id=&#34;move-into-the-cloud:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Move into the Cloud&lt;/h2&gt;

&lt;p&gt;Before we can move our newly build Go based web app to the Swisscom App Cloud, we have to do some preparations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Setup a Swisscom Developer Account&lt;/li&gt;
&lt;li&gt;Specify our dependencies with Godep&lt;/li&gt;
&lt;li&gt;Create a Cloud Foundry manifest.yml&lt;/li&gt;
&lt;li&gt;Upload everything to the cloud&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;setup-a-swisscom-developer-account:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Setup a Swisscom Developer Account&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t go into all the details, because they are already outlined in this &lt;a href=&#34;https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt;.
For the brave, just head to &lt;a href=&#34;https://console.developer.swisscom.com/&#34; target=&#34;_blank&#34;&gt;Swisscom Developer Account&lt;/a&gt; and follow the instructions (you will need a credit card in order to precede).&lt;/p&gt;

&lt;h3 id=&#34;specify-our-dependencies-with-godep:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Specify our Dependencies with Godep&lt;/h3&gt;

&lt;p&gt;Even if we don&amp;rsquo;t use any external dependencies, because all used packages belong to the Go standard library, the file, describing the dependencies for our program has still to be present.&lt;/p&gt;

&lt;p&gt;This file is auto generated with the command &lt;code&gt;godep save -r&lt;/code&gt; (assuming the &lt;em&gt;godep&lt;/em&gt; command resides within the &lt;code&gt;$PATH&lt;/code&gt;). This will create a new directory named &lt;em&gt;Godeps&lt;/em&gt;. Within this directory we find a file called &lt;em&gt;Godeps.json&lt;/em&gt; with a content like to following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;ImportPath&amp;quot;: &amp;quot;github.com/breml/appcloud&amp;quot;,
	&amp;quot;GoVersion&amp;quot;: &amp;quot;go1.5.2&amp;quot;,
	&amp;quot;Deps&amp;quot;: []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a properly setup &lt;code&gt;$GOPATH&lt;/code&gt; and your web app for the app cloud is placed within the &lt;code&gt;$PATH/src/&lt;/code&gt;, everything should be fine.&lt;/p&gt;

&lt;p&gt;If this is not the case, for whatever reason you have to manually modify the just generated &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; file in order to work with the Go buildpack. Most likely the line with &lt;code&gt;ImportPath&lt;/code&gt; reads as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;ImportPath&amp;quot;: &amp;quot;.&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the &amp;ldquo;.&amp;rdquo; has to be replaced with the directory name, where your go web app resides. If you have followed the instructions above, your directory is named &lt;em&gt;appcloud&lt;/em&gt; and you have to replace the above line with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;ImportPath&amp;quot;: &amp;quot;appcloud&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-cloud-foundry-manifest-yml:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Create a Cloud Foundry manifest.yml&lt;/h3&gt;

&lt;p&gt;From the Cloud Foundry &lt;a href=&#34;https://docs.developer.swisscom.com/apps/deploy-apps/manifest.html&#34; target=&#34;_blank&#34;&gt;docs&lt;/a&gt; we learn about &lt;em&gt;manifest.yml&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The application manifest tell the &lt;code&gt;cf push&lt;/code&gt; command what to do with applications. This includes everything from how many instances to create and how much memory to allocate to what services applications should use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For our small Go web app, we need to provide the following information within the &lt;code&gt;manifest.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;---
applications:
- name: DemoApp
  memory: 64M
  host: demoapp&amp;lt;YOURNUMBER&amp;gt;
  buildpack: https://github.com/cloudfoundry/go-buildpack.git
  command: appcloud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In detail:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;name&lt;/em&gt;: name of the app within the app cloud.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;memory&lt;/em&gt;: how much memory should be provided for the app. For our small Go example the minimum setting of 64M is by far enough.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;host&lt;/em&gt;: hostname of the app. This name combined with the assigned domain will be the URL for the app (E. g. demoapp.scapp.io). You should replace &lt;code&gt;&amp;lt;YOURNUMBER&amp;gt;&lt;/code&gt; with a random number of yours. If you catch a hostname, which is already taken, you will be notified while pushing the app.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;buildpack&lt;/em&gt;: for Go apps, the recommended buildpack is the mentioned above. This provides framework and runtime support for Go apps.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;command&lt;/em&gt;: Our Go source code, including the respective dependencies managed by &lt;em&gt;Godep&lt;/em&gt;, will be compiled while pushing to the app cloud with the provided support by the buildpack. The result will be an executable. The &lt;em&gt;command&lt;/em&gt; setting tells the app cloud which program to execute.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;upload-everything-to-the-cloud:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Upload Everything to the Cloud&lt;/h3&gt;

&lt;p&gt;Now with everything set, we may login at the Swisscom App Cloud with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf login -a https://api.lyra-836.appcloud.swisscom.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and finally deploy our application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything is successful, you may now access your &amp;ldquo;Hello world&amp;rdquo; app at &lt;a href=&#34;http://demoapp&amp;lt;YOURNUMBER&amp;gt;.scapp.io/&#34; target=&#34;_blank&#34;&gt;http://demoapp&amp;lt;YOURNUMBER&amp;gt;.scapp.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;annex:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Annex&lt;/h2&gt;

&lt;p&gt;An extended version of the example, described in this blog post, may be found on &lt;a href=&#34;https://github.com/breml/appcloud&#34; target=&#34;_blank&#34;&gt;github.com/breml/appcloud&lt;/a&gt;. Commit &lt;a href=&#34;https://github.com/breml/appcloud/tree/dcb5ce9d&#34; target=&#34;_blank&#34;&gt;dcb5ce9d&lt;/a&gt; does correspond to this post.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;original post&lt;/a&gt; you may find information about scaling your app and combining your app with services.&lt;/p&gt;

&lt;h2 id=&#34;updates:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Updates&lt;/h2&gt;

&lt;h3 id=&#34;17-12-2015:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;17.12.2015&lt;/h3&gt;

&lt;p&gt;Just found out, Go version 1.5 is not supported by the buildpack. Therefore we have to provide the Go version in &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; including the minor version (1.5.1 or 1.5.2) even though &lt;em&gt;godep&lt;/em&gt; in the latest version suggests to only specify the major version of Go.&lt;/p&gt;

&lt;p&gt;Warning by &lt;em&gt;godep&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;godep: WARNING: Recorded go version (go1.5.2) with minor version string found.
godep: To record current major go version run `godep update -goversion`.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tagging of dynamically added Fields in Elasticsearch</title>
      <link>https://breml.github.io/blog/2015/10/28/tagging-of-dynamically-added-fields-in-elasticsearch/</link>
      <pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/28/tagging-of-dynamically-added-fields-in-elasticsearch/</guid>
      <description>

&lt;p&gt;At work we use the ELK Stack (Elasticsearch, Logstash and Kibana) to process, store and visualize all kind of log data. To get the most out of the information stored in Elasticsearch, we maintain a handcrafted Elasticsearch mapping.&lt;/p&gt;

&lt;p&gt;As we are in the process of continuously adding more and more log sources, now and then our Elasticsearch mapping is not complete. In this case the dynamic mapping feature of Elasticsearch adds these new fields by it&amp;rsquo;s own.&lt;/p&gt;

&lt;p&gt;As we want to keep our Elasticsearch mapping up to date we have been looking for an easy way to identify all the new fields dynamically added.&lt;/p&gt;

&lt;h2 id=&#34;naive-approach:21bceea47ef0daa27dbdfefe21d795ad&#34;&gt;Naive approach&lt;/h2&gt;

&lt;p&gt;The naive approach to find the differences between our handcrafted mapping and the actual mapping, used by Elasticsearch for the respective index (possibly with dynamically added fields), would be a simple &lt;code&gt;diff&lt;/code&gt; of two text files.&lt;/p&gt;

&lt;p&gt;The handcrafted mapping is stored as a simple JSON-file, which is used by Logstash to apply the mapping when a new index is created.&lt;/p&gt;

&lt;p&gt;The active mapping is accessible via the Elasticsearch API, for example with &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/logstash-2015.10.28/_mapping&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is, these two files are not directly comparable, for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are not equally formated (may be corrected by tools like &lt;code&gt;jq&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;They do not necessarily include the same settings for the defined fields, as Elasticsearch does not provide settings, which are set to the default value and our handcrafted mapping may include settings which are the default value&lt;/li&gt;
&lt;li&gt;The order of the attributes may not necessarily be the same&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So it is obvious a naive &lt;code&gt;diff&lt;/code&gt; of the two files does not lead the goal, even if we ensure the same formating for both files by using a tool like &lt;a href=&#34;https://stedolan.github.io/jq/&#34; target=&#34;_blank&#34;&gt;jq&lt;/a&gt;. Even if we use JSON aware tools to find the differences, like &lt;a href=&#34;http://json-delta.readthedocs.org/en/latest/&#34; target=&#34;_blank&#34;&gt;json-delta&lt;/a&gt;, we do not get the right result as these tools are not able to determine, where field settings are included in the handcrafted mapping file, which are set to the default value.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-field-template-and-custom-field-analyzer:21bceea47ef0daa27dbdfefe21d795ad&#34;&gt;Dynamic field template and custom field analyzer&lt;/h2&gt;

&lt;p&gt;So we looked for an other way to achieve the goal and we came up with the following solution.&lt;/p&gt;

&lt;p&gt;Elasticsearch does provide two features, which combined provide a easy solution to identify all dynamically added fields:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Elasticsearch allows to define the dynamic mapping, which is used, if a certain field is not currently present in the mapping&lt;/li&gt;
&lt;li&gt;Elasticsearch allows to define custom analyzers, used to analyze the content of a field in a certain way.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we did is defining a custom analyzer called &lt;em&gt;unknown_field_analyzer&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;template&amp;quot; : &amp;quot;logstash-*&amp;quot;,
  &amp;quot;settings&amp;quot; : {
    &amp;quot;analysis&amp;quot; : {
      &amp;quot;analyzer&amp;quot; : {
        &amp;quot;unknown_field_analyzer&amp;quot; : {
          &amp;quot;type&amp;quot; : &amp;quot;whitespace&amp;quot;
        }
      }
    }
  }
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(snipped of &lt;em&gt;analyzers&lt;/em&gt; section of the Elasticsearch mapping)&lt;/p&gt;

&lt;p&gt;This analyzer we apply in the definition for the dynamic templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;dynamic_templates&amp;quot; : [
    {
      &amp;quot;string_fields&amp;quot; : {
        &amp;quot;mapping&amp;quot; : {
          &amp;quot;index&amp;quot; : &amp;quot;analyzed&amp;quot;,
          &amp;quot;omit_norms&amp;quot; : true,
          &amp;quot;analyzer&amp;quot; : &amp;quot;unknown_field_analyzer&amp;quot;,
          &amp;quot;type&amp;quot; : &amp;quot;string&amp;quot;
        },
        &amp;quot;match_mapping_type&amp;quot; : &amp;quot;string&amp;quot;,
        &amp;quot;match&amp;quot; : &amp;quot;*&amp;quot;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(snipped of _dynamic&lt;em&gt;templates&lt;/em&gt; section of the Elasticsearch mapping)&lt;/p&gt;

&lt;p&gt;This leads to the a mapping, where all dynamically added fields are doubtless identified by the setting &lt;em&gt;analyzer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now it is easy to list all dynamically added fields by a small script, using the already mentioned tool &lt;code&gt;jq&lt;/code&gt; (requires at least version 1.5):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/logstash-2015.10.28/_mapping&#39; 2&amp;gt;/dev/null | jq &#39;.[].mappings | to_entries | .[] | .key as $mapping | .value.properties | to_entries | .[] | .key as $property | if .value.analyzer? == &amp;quot;unknown_field_analyzer&amp;quot; then &amp;quot;mapping: &amp;quot; + $mapping + &amp;quot;, property: &amp;quot; + $property else empty end&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script returns the following example output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;mapping: mylog, property: newfield&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the main idea of the above script a monitoring system could easily alert if new fields have been dynamically added.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dividable without remainder</title>
      <link>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</link>
      <pubDate>Thu, 22 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</guid>
      <description>

&lt;h2 id=&#34;summary:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Summary&lt;/h2&gt;

&lt;h3 id=&#34;problem:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;For a &amp;ldquo;1 in n sampling&amp;rdquo; problem I was looking for a fast way to determine, if a value &lt;em&gt;x&lt;/em&gt; (random number) is dividable by a previously known divisor &lt;em&gt;d&lt;/em&gt; (sampling rate) without remainder. So the algorithm has to result with &lt;em&gt;true&lt;/em&gt; in &lt;em&gt;1&lt;/em&gt; of &lt;em&gt;d&lt;/em&gt; cases, otherwise with &lt;em&gt;false&lt;/em&gt;. &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; are both unsigned integers, in my case 32 bit long. Since the algorithm will be used for sampling and &lt;em&gt;x&lt;/em&gt; is produced by a random number generator (see below: Motivation), a slight inaccuracy (&amp;lt; 0.01%) may be tolerable. The usual range for &lt;em&gt;d&lt;/em&gt; will be whole numbers between 1 and 2000, based on the recommendations for &lt;a href=&#34;http://blog.sflow.com/2009/06/sampling-rates.html&#34; target=&#34;_blank&#34;&gt;sFlow sampling rates&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;tl;dr Solution&lt;/h3&gt;

&lt;p&gt;The obvious solution of course is to use the modulo operation: &lt;code&gt;x % d == 0&lt;/code&gt;. In my special case, the modulo operation is not available, and I therefore had to look for an alternative (for details see: Motivation).&lt;/p&gt;

&lt;p&gt;The proposed solution only works with positive (unsigned) values.&lt;br /&gt;
&lt;em&gt;d = 0&lt;/em&gt; is not allowed (division by 0); for &lt;em&gt;d = 1&lt;/em&gt;, the result is always true.&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;d&lt;/em&gt; is a power of 2 (e.g. 4, 8, 16), the result is determined with &lt;code&gt;x &amp;amp; (d - 1) == 0&lt;/code&gt;. If true, there is no remainder.&lt;/p&gt;

&lt;p&gt;For all other cases, the following calculation is performed:&lt;br /&gt;
&lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt;&lt;br /&gt;
The reciprocal function is defined as:&lt;br /&gt;
&lt;code&gt;reciprocal(d) = maxuint / d + 1&lt;/code&gt;&lt;br /&gt;
where the division is an integer division, where the result is round down.&lt;br /&gt;
&lt;em&gt;maxuint&lt;/em&gt; is the maximum unsigned integer value of the used data type, in my case 32 bit (&lt;em&gt;maxuint = 2^32 - 1 = 4294967295&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;The check, if &lt;em&gt;d&lt;/em&gt; is a power of 2 and the calculation of &lt;em&gt;reciprocal(d)&lt;/em&gt; is performed only once at initialization, because the sampling-rate is constant during the whole sampling process.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;x&lt;/em&gt; in 0 to &lt;em&gt;maxuint&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; from 1 to 10000 (inclusive) the proposed algorithm returns in 9988 cases the same count of return value = &lt;em&gt;true&lt;/em&gt; (and respectively &lt;em&gt;false&lt;/em&gt;) as the exact method &lt;code&gt;x % d == 0&lt;/code&gt;. In the other 12 cases, the difference of the counts of return value = &lt;em&gt;true&lt;/em&gt; is 1, which leads to an inaccuracy below 0.001%.&lt;/p&gt;

&lt;p&gt;These results are verified by a small program of mine, called &lt;a href=&#34;https://github.com/breml/zeroremainder&#34; target=&#34;_blank&#34;&gt;zeroremainder&lt;/a&gt; available at Github.&lt;/p&gt;

&lt;h3 id=&#34;bottom-line:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Bottom Line&lt;/h3&gt;

&lt;p&gt;The proposed algorithm is usable for the use case in question, as the difference of the results compared to the exact method, using the modulo operation, is marginal (below 0.001%).&lt;/p&gt;

&lt;h2 id=&#34;motivation:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;I am working on a tool, to sample network packets at arbitrary sampling rate (normally between 1 and 2000), as proposed by &lt;a href=&#34;http://www.sflow.org&#34; target=&#34;_blank&#34;&gt;sFlow&lt;/a&gt;). My implementation is based on &lt;a href=&#34;https://github.com/google/gopacket&#34; target=&#34;_blank&#34;&gt;gopacket&lt;/a&gt;, which uses libpcap, the same library used by &lt;a href=&#34;http://www.tcpdump.org/&#34; target=&#34;_blank&#34;&gt;tcpdump&lt;/a&gt;. One of my approaches for the sampling of the packages is based on &lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/filter.txt&#34; target=&#34;_blank&#34;&gt;BPF (Berkeley Packet Filter)&lt;/a&gt;, which allows to filter the captured packets in the kernel. The assumption is that filtering in kernel mode should be faster, because there are less context switches and memory copy operations necessary. BPF allows to call the &lt;em&gt;prandom&lt;/em&gt; interface of the kernel to get a random uint32 number. One way to decide, if the current packet should be sampled, is to use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Modulo_operation&#34; target=&#34;_blank&#34;&gt;modulo&lt;/a&gt; operation; random number modulo sampling rate. If the remainder is 0, the packet is sampled, otherwise the packet is ignored.&lt;/p&gt;

&lt;p&gt;Although BPF assembler does provide a modulo instruction, I do not want to use this instruction because of two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The modulo BPF instruction is not supported with libpcap &amp;lt; 1.6.0&lt;/li&gt;
&lt;li&gt;Unsigned integer division (and therefore modulo) is one of the slowest operations on a modern microprocessor (see benchmark results below)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;inspiration:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Inspiration&lt;/h2&gt;

&lt;p&gt;While searching the web for possible solutions, which could be implemented easily in assembler, I stumbled over &lt;a href=&#34;https://courses.engr.illinois.edu/ece390/books/artofasm/CH09/CH09-6.html#HEADING6-39&#34; target=&#34;_blank&#34;&gt;Division Without DIV and IDIV&lt;/a&gt; and the concept of magic numbers (&lt;a href=&#34;http://stackoverflow.com/a/2661840&#34; target=&#34;_blank&#34;&gt;Stackoverflow - Most optimized way to calculate modulus in C&lt;/a&gt;, &lt;a href=&#34;http://www.hackersdelight.org/magic.htm&#34; target=&#34;_blank&#34;&gt;Magic number generator&lt;/a&gt;, &lt;a href=&#34;http://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html&#34; target=&#34;_blank&#34;&gt;Labor of Division&lt;/a&gt;) which replaces division by a multiplication with a magic number and a binary shift operation.&lt;/p&gt;

&lt;p&gt;Inspired by this ideas I started to experiment with reciprocal, magic numbers and overflow of unsigned integers.&lt;/p&gt;

&lt;h2 id=&#34;solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;preconditions:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Preconditions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;We only work with unsigned integers, where the &lt;em&gt;size&lt;/em&gt; of the integer is a multiple of 8 (bits), normally one of 8, 16, 32, 64 (depending on data type and architecture)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;maxuint&lt;/em&gt; is defined as: &lt;code&gt;maxuint = 2^size - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The divisor &lt;em&gt;d&lt;/em&gt; must not be &lt;em&gt;0&lt;/em&gt; (would lead to division by 0 error)&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;d&lt;/em&gt; is &lt;em&gt;1&lt;/em&gt;, no calculation is performed, the result is always &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The dividend &lt;em&gt;x&lt;/em&gt; may be any number in the range from &lt;em&gt;0&lt;/em&gt; to &lt;em&gt;maxuint&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;d-being-a-power-of-2:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;&lt;strong&gt;d&lt;/strong&gt; being a power of 2&lt;/h3&gt;

&lt;p&gt;This part of the solution is straightforward. If &lt;em&gt;d&lt;/em&gt; is a power of 2 (e.g. 4, 8, 16), the modulo could by determined with a simple &lt;em&gt;and&lt;/em&gt; operation, &lt;code&gt;x &amp;amp; (d - 1) == 0&lt;/code&gt;. The result of a bitwise &lt;em&gt;and&lt;/em&gt;-operation of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d - 1&lt;/em&gt; is the remainder. Therefore if the result is 0, there is no remainder and the equation is &lt;em&gt;true&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;multiply-by-reciprocal:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Multiply by reciprocal&lt;/h3&gt;

&lt;p&gt;For all other cases (&lt;em&gt;d&lt;/em&gt; not being a power of 2), the basic idea is, to perform a multiplication of &lt;em&gt;x&lt;/em&gt; and the reciprocal of &lt;em&gt;d&lt;/em&gt;, calculated on the base of &lt;em&gt;maxuint&lt;/em&gt;, the maximum integer value of respective data type or architecture (e.g. 32 bit), and use the &lt;em&gt;free&lt;/em&gt; wrap around modulo operation of the integer overflow. The integer overflow is described in &lt;a href=&#34;https://en.wikipedia.org/wiki/Integer_overflow&#34; target=&#34;_blank&#34;&gt;Wikipedia - Integer overflow&lt;/a&gt; as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Since an arithmetic operation may produce a result larger than the maximum representable value, a potential error condition may result. In the C programming language, signed integer overflow causes undefined behavior, while unsigned integer overflow causes the number to be reduced modulo a power of two, meaning that unsigned integers &amp;ldquo;wrap around&amp;rdquo; on overflow.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First we handle some special cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;x == 0&lt;/em&gt; the result is always &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;0 &amp;lt; x &amp;lt; d&lt;/em&gt; no calculation is performed as the result has to be false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The elimination of these special cases ensures that a wrap around modulo operation is always performed.&lt;/p&gt;

&lt;p&gt;For the remaining cases (&lt;em&gt;x &amp;gt; d&lt;/em&gt;) the following calculation is performed to decide if a packet should be sampled or not:&lt;br /&gt;
&lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The used reciprocal is calculated as rounded up division of &lt;em&gt;maxuint&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt;, the division being an integer division, where the result is round down):&lt;br /&gt;
&lt;code&gt;reciprocal(d) = maxuint / d + 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;One of the first question I asked my self about this equation was, why has *x * reciprocal(d)* to be smaller than &lt;em&gt;reciprocal(d)&lt;/em&gt;?  To explain this, let&amp;rsquo;s have a look at an example with &lt;em&gt;d&lt;/em&gt; being a power of 2. We know, if &lt;em&gt;d&lt;/em&gt; is a power of 2, there is a simpler approach to determine, if a &lt;em&gt;x&lt;/em&gt; is dividable by &lt;em&gt;d&lt;/em&gt; without remainder, by using the bitwise &lt;em&gt;and&lt;/em&gt;-operation described above.&lt;br /&gt;
Nevertheless we may use the proposed algorithm. In this case *x * reciprocal(d)* will always result to &lt;em&gt;0&lt;/em&gt;, if &lt;em&gt;x&lt;/em&gt; is dividable by &lt;em&gt;d&lt;/em&gt; without remainder. This works because in this case &lt;em&gt;reciprocal(d)&lt;/em&gt; results in the effective reciprocal value of d, without rounding error. For all other &lt;em&gt;d&lt;/em&gt;, not being a power of 2, &lt;em&gt;reciprocal(d)&lt;/em&gt; is always a rounded value, with &lt;em&gt;0 &amp;lt; error &amp;lt; 1&lt;/em&gt;.&lt;br /&gt;
The &lt;em&gt;error&lt;/em&gt; may be calculated as follows:&lt;br /&gt;
&lt;code&gt;reciprocal(d) - 2^size / d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This rounding error is the reason, why *x * reciprocal(d)* does not equal to &lt;em&gt;0&lt;/em&gt; if &lt;code&gt;x % d = 0&lt;/code&gt;. The higher &lt;em&gt;x&lt;/em&gt;, the higher the accumulated &lt;em&gt;error&lt;/em&gt; becomes, as the &lt;em&gt;error&lt;/em&gt; is multiplied by &lt;em&gt;x&lt;/em&gt; as well. Now it becomes clear, there is a point where the accumulated &lt;em&gt;error&lt;/em&gt; even exceeds &lt;em&gt;reciprocal(d)&lt;/em&gt;, which leads to the situation, where &lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt; does not provide the same result as &lt;code&gt;x % d == 0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;(2^size / d) / error&lt;/code&gt; (integer division) the highest &lt;em&gt;x&lt;/em&gt; may be calculated, where the proposed algorithm still provides the same result as &lt;code&gt;x % d = 0&lt;/code&gt;. Unfortunately this buys us nothing, because in my scenario &lt;em&gt;x&lt;/em&gt; may be any number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;maxuint&lt;/em&gt;. So the next question arises, what happens there or a little bit bolder: does it matter? The short answer is: no, for my use case it does not matter. Why?&lt;/p&gt;

&lt;p&gt;We could understand the proposed algorithm &lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt; as a kind of sliding window with the size of &lt;em&gt;d&lt;/em&gt;. Because we can not exactly represent the reciprocal of &lt;em&gt;d&lt;/em&gt; as whole number, the sliding window is a little bit bigger than &lt;em&gt;d&lt;/em&gt;. This leads to a difference between the proposed algorithm and the exact calculation, but the proposed algorithm still fulfills the requirement of selecting approximately every nth element (respectively every *d*th).&lt;/p&gt;

&lt;h3 id=&#34;applied-verification:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Applied verification&lt;/h3&gt;

&lt;p&gt;The verify the above statements, I wrote a small program, called &lt;a href=&#34;https://github.com/breml/zeroremainder&#34; target=&#34;_blank&#34;&gt;zeroremainder&lt;/a&gt; available at Github.&lt;/p&gt;

&lt;p&gt;This program allows to compare the results of the proposed algorithm with the result of the exact method (modulo operation) and calculate the difference of the results.&lt;/p&gt;

&lt;p&gt;As I am primarily interested in the results on 32 bit data types and for divisors between 1 and 2000, my applied verification was focused on these parameters, while the &lt;em&gt;zeroremainder&lt;/em&gt; test program does allow to check other number ranges as well.&lt;/p&gt;

&lt;h4 id=&#34;results:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Results&lt;/h4&gt;

&lt;p&gt;I ran &lt;code&gt;zeroremainder&lt;/code&gt; on my 4 core i5 2.67 GHz for about 60 hours, using 100% CPU, to fully calculate the divisors from 2 to 10000 (inclusive) with dividends from 0 to 2^32-1.&lt;/p&gt;

&lt;p&gt;Executed command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;zeroremainder -outputalldivisors -dividendend=0xffffffff -divisorend=10000 &amp;gt; 0_to_0xffffffff_2_to_10000_alldivisors.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results of these calculations are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The proposed algorithm returns in 9988 cases the same count of return value = &lt;em&gt;true&lt;/em&gt; (and respectively &lt;em&gt;false&lt;/em&gt;) as the exact method &lt;code&gt;x % d == 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the other 12 cases (divisors: 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369), the difference of the counts of return value = &lt;em&gt;true&lt;/em&gt; is exactly 1, which leads to an inaccuracy below 0.001%.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For easier verification of the results I sorted these by divisor and added a column with an exact value for the difference between the proposed algorithm and the modulo operation as a percent value as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;cat 0_to_0xffffffff_2_to_10000_alldivisors.txt | sort -n -k 2 | awk &#39; {print $0 &amp;quot; Difference exact (%): &amp;quot; sprintf(&amp;quot;%.16f&amp;quot;, 100-100/$8*$5)}&#39; &amp;gt; 0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may download these results as compressed bz2 archive &lt;a href=&#34;https://breml.github.io/downloads/0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2&#34;&gt;0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;benchmarks:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Benchmarks&lt;/h4&gt;

&lt;p&gt;To get a feeling about the performance difference of the different algorithms I implemented a small go benchmark.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ go test -bench=.        
testing: warning: no tests to run
PASS
BenchmarkDivisionMod-4        	100000000	        11.1 ns/op
BenchmarkDivisionPow2-4       	300000000	         4.21 ns/op
BenchmarkZeroremainderUint32-4	300000000	         4.46 ns/op
BenchmarkZeroremainderUint64-4	300000000	         4.50 ns/op
BenchmarkDivisionLt-4         	500000000	         3.34 ns/op
ok  	_/home/lubr/go/src/github.com/breml/zeroremainder	8.439s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am aware of the fact that these results are not comparable with the implementation of this calculations in BPF, but the give me a feeling about the dimensions.&lt;/p&gt;

&lt;h2 id=&#34;the-easiest-solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;The easiest solution&lt;/h2&gt;

&lt;p&gt;While working on this solution I became aware of an even easier way to do the sampling by evaluating &lt;code&gt;x &amp;lt; maxuint / d&lt;/code&gt;. The part &lt;em&gt;maxuint / d&lt;/em&gt; may be calculated at initialization (like &lt;em&gt;reciprocal(d)&lt;/em&gt;), where &lt;em&gt;maxuint&lt;/em&gt; is the maximum number generated by the random number generator.&lt;/p&gt;

&lt;p&gt;With this solution a simple comparison is enough to determine if a packet should be sampled or not.&lt;/p&gt;

&lt;p&gt;This solution may be used, if the source for the random numbers guarantees for a even distribution of the random numbers throughout the whole range of possible numbers.&lt;/p&gt;

&lt;h2 id=&#34;disclaimer:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Disclaimer&lt;/h2&gt;

&lt;p&gt;This document is a compilation of observations and empirical studies of the described algorithm and by no means a formal proof.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gogitignore</title>
      <link>https://breml.github.io/blog/2015/10/06/gogitignore/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/06/gogitignore/</guid>
      <description>

&lt;p&gt;The other day I extended one of my go (golang) project with some new main packages resulting in new commands. After building the project with &lt;code&gt;go build&lt;/code&gt; the resulting executables are placed in the respective directories within the project. While updating the git repository I found it cumbersome to add all the new executables to the .gitignore-file. On linux there is unfortunately now easy way to exclude all executables within a project with a single line in .gitignore.&lt;/p&gt;

&lt;p&gt;With go it is easily predictable how the resulting executables from a main package are named. The directory name, containing a main package, will be used as filename for the new command. Hence I hacked some lines of go code to automatically update the .gitignore file. The result is the &lt;a href=&#34;https://github.com/breml/gogitignore&#34; target=&#34;_blank&#34;&gt;gogitignore&lt;/a&gt;. At the moment it still a bit rough around the edges, but the main idea is already implemented.&lt;/p&gt;

&lt;h2 id=&#34;usage:82ed5a67ff3dec1227a0a5d6b8aae203&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;In the easiest case you may just run &lt;code&gt;gogitignore&lt;/code&gt; in the root directory of your go project. This will add all executables, build from the main packages, automatically as an entry to the .gitignore file in the project root directory. To double check the result gogitignore provides the flag -stdout (or -dryrun).&lt;/p&gt;

&lt;p&gt;For more information about the usage run &lt;code&gt;gogitignore -h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-dir=&amp;quot;.&amp;quot;: destination directory where .gitignore is located and where to traverse directory tree for go programs.
-dryrun=false: dryrun, no changes are made
-exec=false: find all files with executable bit set
-gomain=true: add executables, resulting from building go main packages
-h=false: print usage
-help=false: print usage
-inplace=false: edit .gitignore in place
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>