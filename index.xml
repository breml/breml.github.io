<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>breml&#39;s blog</title>
    <link>https://breml.github.io/</link>
    <description>Recent content on breml&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Oct 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://breml.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tagging of dynamically added Fields in Elasticsearch</title>
      <link>https://breml.github.io/blog/2015/10/28/tagging-of-dynamically-added-fields-in-elasticsearch/</link>
      <pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/28/tagging-of-dynamically-added-fields-in-elasticsearch/</guid>
      <description>

&lt;p&gt;At work we use the ELK Stack (Elasticsearch, Logstash and Kibana) to process, store and visualize all kind of log data. To get the most out of the information stored in Elasticsearch, we maintain a handcrafted Elasticsearch mapping.&lt;/p&gt;

&lt;p&gt;As we are in the process of continuously adding more and more log sources, now and then our Elasticsearch mapping is not complete. In this case the dynamic mapping feature of Elasticsearch adds these new fields by it&amp;rsquo;s own.&lt;/p&gt;

&lt;p&gt;As we want to keep our Elasticsearch mapping up to date we have been looking for an easy way to identify all the new fields dynamically added.&lt;/p&gt;

&lt;h2 id=&#34;naive-approach:21bceea47ef0daa27dbdfefe21d795ad&#34;&gt;Naive approach&lt;/h2&gt;

&lt;p&gt;The naive approach to find the differences between our handcrafted mapping and the actual mapping, used by Elasticsearch for the respective index (possibly with dynamically added fields), would be a simple &lt;code&gt;diff&lt;/code&gt; of two text files.&lt;/p&gt;

&lt;p&gt;The handcrafted mapping is stored as a simple JSON-file, which is used by Logstash to apply the mapping when a new index is created.&lt;/p&gt;

&lt;p&gt;The active mapping is accessible via the Elasticsearch API, for example with &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/logstash-2015.10.28/_mapping&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is, these to files are not directly comparable, for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are not equally formated (may be corrected by tools like &lt;code&gt;jq&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;They do not necessarily include the same settings for the defined fields, as Elasticsearch does not provide settings, which are set to the default value and our handcrafted mapping may include settings which are the default value&lt;/li&gt;
&lt;li&gt;The order of the attributes may not necessarily be the same&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So it is obvious a naive &lt;code&gt;diff&lt;/code&gt; of the two files does not lead the goal, even if we ensure the same formating for both files by using a tool like &lt;a href=&#34;https://stedolan.github.io/jq/&#34; target=&#34;_blank&#34;&gt;jq&lt;/a&gt;. Even if we use JSON aware tools to find the differences, like &lt;a href=&#34;http://json-delta.readthedocs.org/en/latest/&#34; target=&#34;_blank&#34;&gt;json-delta&lt;/a&gt;, we do not get the right result as these tools are not able to determine, where field settings are included in the handcrafted mapping file, which are set to the default value.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-field-template-and-custom-field-analyzer:21bceea47ef0daa27dbdfefe21d795ad&#34;&gt;Dynamic field template and custom field analyzer&lt;/h2&gt;

&lt;p&gt;So we looked for an other way to achieve the goal and we came up with the following solution.&lt;/p&gt;

&lt;p&gt;Elasticsearch does provide two features, which combined provide a easy solution to identify all dynamically added fields:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Elasticsearch allows to define the dynamic mapping, which is used, if a certain field is not currently present in the mapping&lt;/li&gt;
&lt;li&gt;Elasticsearch allows to define custom analyzers, used to analyze the content of a field in a certain way.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we did is defining a custom analyzer called &lt;em&gt;unknown_field_analyzer&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;template&amp;quot; : &amp;quot;logstash-*&amp;quot;,
  &amp;quot;settings&amp;quot; : {
    &amp;quot;analysis&amp;quot; : {
      &amp;quot;analyzer&amp;quot; : {
        &amp;quot;unknown_field_analyzer&amp;quot; : {
          &amp;quot;type&amp;quot; : &amp;quot;whitespace&amp;quot;
        }
      }
    }
  }
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(snipped of &lt;em&gt;analyzers&lt;/em&gt; section of the Elasticsearch mapping)&lt;/p&gt;

&lt;p&gt;This analyzer we apply in the definition for the dynamic templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;dynamic_templates&amp;quot; : [
    {
      &amp;quot;string_fields&amp;quot; : {
        &amp;quot;mapping&amp;quot; : {
          &amp;quot;index&amp;quot; : &amp;quot;analyzed&amp;quot;,
          &amp;quot;omit_norms&amp;quot; : true,
          &amp;quot;analyzer&amp;quot; : &amp;quot;unknown_field_analyzer&amp;quot;,
          &amp;quot;type&amp;quot; : &amp;quot;string&amp;quot;
        },
        &amp;quot;match_mapping_type&amp;quot; : &amp;quot;string&amp;quot;,
        &amp;quot;match&amp;quot; : &amp;quot;*&amp;quot;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(snipped of &lt;em&gt;dynamic_templates&lt;/em&gt; section of the Elasticsearch mapping)&lt;/p&gt;

&lt;p&gt;This leads to the a mapping, where all dynamically added fields are doubtless identified by the setting &lt;em&gt;analyzer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now it is easy to list all dynamically added fields by a small script, using the already mentioned tool &lt;code&gt;jq&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/logstash-2015.10.28/_mapping&#39; 2&amp;gt;/dev/null | jq &#39;.[].mappings | to_entries | .[] | .key as $mapping | .value.properties | to_entries | .[] | .key as $property | if .value.analyzer? == &amp;quot;unknown_field_analyzer&amp;quot; then &amp;quot;mapping: &amp;quot; + $mapping + &amp;quot;, property: &amp;quot; + $property else empty end&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script returns the following example output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;mapping: mylog, property: newfield&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the main idea of the above script a monitoring system could easily alert if new fields have been dynamically added.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dividable without remainder</title>
      <link>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</link>
      <pubDate>Thu, 22 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</guid>
      <description>

&lt;h2 id=&#34;summary:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Summary&lt;/h2&gt;

&lt;h3 id=&#34;problem:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;For a &amp;ldquo;1 in n sampling&amp;rdquo; problem I was looking for a fast way to determine, if a value &lt;em&gt;x&lt;/em&gt; (random number) is dividable by a previously known divisor &lt;em&gt;d&lt;/em&gt; (sampling rate) without remainder. So the algorithm has to result with &lt;em&gt;true&lt;/em&gt; in &lt;em&gt;1&lt;/em&gt; of &lt;em&gt;d&lt;/em&gt; cases, otherwise with &lt;em&gt;false&lt;/em&gt;. &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; are both unsigned integers, in my case 32 bit long. Since the algorithm will be used for sampling and &lt;em&gt;x&lt;/em&gt; is produced by a random number generator (see below: Motivation), a slight inaccuracy (&amp;lt; 0.01%) may be tolerable. The usual range for &lt;em&gt;d&lt;/em&gt; will be whole numbers between 1 and 2000, based on the recommendations for &lt;a href=&#34;http://blog.sflow.com/2009/06/sampling-rates.html&#34; target=&#34;_blank&#34;&gt;sFlow sampling rates&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;tl;dr Solution&lt;/h3&gt;

&lt;p&gt;The obvious solution of course is to use the modulo operation: &lt;code&gt;x % d == 0&lt;/code&gt;. In my special case, the modulo operation is not available, and I therefore had to look for an alternative (for details see: Motivation).&lt;/p&gt;

&lt;p&gt;The proposed solution only works with positive (unsigned) values.&lt;br /&gt;
&lt;em&gt;d = 0&lt;/em&gt; is not allowed (division by 0); for &lt;em&gt;d = 1&lt;/em&gt;, the result is always true.&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;d&lt;/em&gt; is a power of 2 (e.g. 4, 8, 16), the result is determined with &lt;code&gt;x &amp;amp; (d - 1) == 0&lt;/code&gt;. If true, there is no remainder.&lt;/p&gt;

&lt;p&gt;For all other cases, the following calculation is performed:&lt;br /&gt;
&lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt;&lt;br /&gt;
The reciprocal function is defined as:&lt;br /&gt;
&lt;code&gt;reciprocal(d) = maxuint / d + 1&lt;/code&gt;&lt;br /&gt;
where the division is an integer division, where the result is round down.&lt;br /&gt;
&lt;em&gt;maxuint&lt;/em&gt; is the maximum unsigned integer value of the used data type, in my case 32 bit (&lt;em&gt;maxuint = 2^32 - 1 = 4294967295&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;The check, if &lt;em&gt;d&lt;/em&gt; is a power of 2 and the calculation of &lt;em&gt;reciprocal(d)&lt;/em&gt; is performed only once at initialization, because the sampling-rate is constant during the whole sampling process.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;x&lt;/em&gt; in 0 to &lt;em&gt;maxuint&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; from 1 to 10000 (inclusive) the proposed algorithm returns in 9988 cases the same count of return value = &lt;em&gt;true&lt;/em&gt; (and respectively &lt;em&gt;false&lt;/em&gt;) as the exact method &lt;code&gt;x % d == 0&lt;/code&gt;. In the other 12 cases, the difference of the counts of return value = &lt;em&gt;true&lt;/em&gt; is 1, which leads to an inaccuracy below 0.001%.&lt;/p&gt;

&lt;p&gt;These results are verified by a small program of mine, called &lt;a href=&#34;https://github.com/breml/zeroremainder&#34; target=&#34;_blank&#34;&gt;zeroremainder&lt;/a&gt; available at Github.&lt;/p&gt;

&lt;h3 id=&#34;bottom-line:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Bottom Line&lt;/h3&gt;

&lt;p&gt;The proposed algorithm is usable for the use case in question, as the difference of the results compared to the exact method, using the modulo operation, is marginal (below 0.001%).&lt;/p&gt;

&lt;h2 id=&#34;motivation:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;I am working on a tool, to sample network packets at arbitrary sampling rate (normally between 1 and 2000), as proposed by &lt;a href=&#34;http://www.sflow.org&#34; target=&#34;_blank&#34;&gt;sFlow&lt;/a&gt;). My implementation is based on &lt;a href=&#34;https://github.com/google/gopacket&#34; target=&#34;_blank&#34;&gt;gopacket&lt;/a&gt;, which uses libpcap, the same library used by &lt;a href=&#34;http://www.tcpdump.org/&#34; target=&#34;_blank&#34;&gt;tcpdump&lt;/a&gt;. One of my approaches for the sampling of the packages is based on &lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/filter.txt&#34; target=&#34;_blank&#34;&gt;BPF (Berkeley Packet Filter)&lt;/a&gt;, which allows to filter the captured packets in the kernel. The assumption is that filtering in kernel mode should be faster, because there are less context switches and memory copy operations necessary. BPF allows to call the &lt;em&gt;prandom&lt;/em&gt; interface of the kernel to get a random uint32 number. One way to decide, if the current packet should be sampled, is to use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Modulo_operation&#34; target=&#34;_blank&#34;&gt;modulo&lt;/a&gt; operation; random number modulo sampling rate. If the remainder is 0, the packet is sampled, otherwise the packet is ignored.&lt;/p&gt;

&lt;p&gt;Although BPF assembler does provide a modulo instruction, I do not want to use this instruction because of two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The modulo BPF instruction is not supported with libpcap &amp;lt; 1.6.0&lt;/li&gt;
&lt;li&gt;Unsigned integer division (and therefore modulo) is one of the slowest operations on a modern microprocessor (see benchmark results below)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;inspiration:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Inspiration&lt;/h2&gt;

&lt;p&gt;While searching the web for possible solutions, which could be implemented easily in assembler, I stumbled over &lt;a href=&#34;https://courses.engr.illinois.edu/ece390/books/artofasm/CH09/CH09-6.html#HEADING6-39&#34; target=&#34;_blank&#34;&gt;Division Without DIV and IDIV&lt;/a&gt; and the concept of magic numbers (&lt;a href=&#34;http://stackoverflow.com/a/2661840&#34; target=&#34;_blank&#34;&gt;Stackoverflow - Most optimized way to calculate modulus in C&lt;/a&gt;, &lt;a href=&#34;http://www.hackersdelight.org/magic.htm&#34; target=&#34;_blank&#34;&gt;Magic number generator&lt;/a&gt;, &lt;a href=&#34;http://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html&#34; target=&#34;_blank&#34;&gt;Labor of Division&lt;/a&gt;) which replaces division by a multiplication with a magic number and a binary shift operation.&lt;/p&gt;

&lt;p&gt;Inspired by this ideas I started to experiment with reciprocal, magic numbers and overflow of unsigned integers.&lt;/p&gt;

&lt;h2 id=&#34;solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;preconditions:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Preconditions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;We only work with unsigned integers, where the &lt;em&gt;size&lt;/em&gt; of the integer is a multiple of 8 (bits), normally one of 8, 16, 32, 64 (depending on data type and architecture)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;maxuint&lt;/em&gt; is defined as: &lt;code&gt;maxuint = 2^size - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The divisor &lt;em&gt;d&lt;/em&gt; must not be &lt;em&gt;0&lt;/em&gt; (would lead to division by 0 error)&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;d&lt;/em&gt; is &lt;em&gt;1&lt;/em&gt;, no calculation is performed, the result is always &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The dividend &lt;em&gt;x&lt;/em&gt; may be any number in the range from &lt;em&gt;0&lt;/em&gt; to &lt;em&gt;maxuint&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;d-being-a-power-of-2:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;&lt;strong&gt;d&lt;/strong&gt; being a power of 2&lt;/h3&gt;

&lt;p&gt;This part of the solution is straightforward. If &lt;em&gt;d&lt;/em&gt; is a power of 2 (e.g. 4, 8, 16), the modulo could by determined with a simple &lt;em&gt;and&lt;/em&gt; operation, &lt;code&gt;x &amp;amp; (d - 1) == 0&lt;/code&gt;. The result of a bitwise &lt;em&gt;and&lt;/em&gt;-operation of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d - 1&lt;/em&gt; is the remainder. Therefore if the result is 0, there is no remainder and the equation is &lt;em&gt;true&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;multiply-by-reciprocal:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Multiply by reciprocal&lt;/h3&gt;

&lt;p&gt;For all other cases (&lt;em&gt;d&lt;/em&gt; not being a power of 2), the basic idea is, to perform a multiplication of &lt;em&gt;x&lt;/em&gt; and the reciprocal of &lt;em&gt;d&lt;/em&gt;, calculated on the base of &lt;em&gt;maxuint&lt;/em&gt;, the maximum integer value of respective data type or architecture (e.g. 32 bit), and use the &lt;em&gt;free&lt;/em&gt; wrap around modulo operation of the integer overflow. The integer overflow is described in &lt;a href=&#34;https://en.wikipedia.org/wiki/Integer_overflow&#34; target=&#34;_blank&#34;&gt;Wikipedia - Integer overflow&lt;/a&gt; as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Since an arithmetic operation may produce a result larger than the maximum representable value, a potential error condition may result. In the C programming language, signed integer overflow causes undefined behavior, while unsigned integer overflow causes the number to be reduced modulo a power of two, meaning that unsigned integers &amp;ldquo;wrap around&amp;rdquo; on overflow.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First we handle some special cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;x == 0&lt;/em&gt; the result is always &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;0 &amp;lt; x &amp;lt; d&lt;/em&gt; no calculation is performed as the result has to be false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The elimination of these special cases ensures that a wrap around modulo operation is always performed.&lt;/p&gt;

&lt;p&gt;For the remaining cases (&lt;em&gt;x &amp;gt; d&lt;/em&gt;) the following calculation is performed to decide if a packet should be sampled or not:&lt;br /&gt;
&lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The used reciprocal is calculated as rounded up division of &lt;em&gt;maxuint&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt;, the division being an integer division, where the result is round down):&lt;br /&gt;
&lt;code&gt;reciprocal(d) = maxuint / d + 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;One of the first question I asked my self about this equation was, why has &lt;em&gt;x * reciprocal(d)&lt;/em&gt; to be smaller than &lt;em&gt;reciprocal(d)&lt;/em&gt;?  To explain this, let&amp;rsquo;s have a look at an example with &lt;em&gt;d&lt;/em&gt; being a power of 2. We know, if &lt;em&gt;d&lt;/em&gt; is a power of 2, there is a simpler approach to determine, if a &lt;em&gt;x&lt;/em&gt; is dividable by &lt;em&gt;d&lt;/em&gt; without remainder, by using the bitwise &lt;em&gt;and&lt;/em&gt;-operation described above.&lt;br /&gt;
Nevertheless we may use the proposed algorithm. In this case &lt;em&gt;x * reciprocal(d)&lt;/em&gt; will always result to &lt;em&gt;0&lt;/em&gt;, if &lt;em&gt;x&lt;/em&gt; is dividable by &lt;em&gt;d&lt;/em&gt; without remainder. This works because in this case &lt;em&gt;reciprocal(d)&lt;/em&gt; results in the effective reciprocal value of d, without rounding error. For all other &lt;em&gt;d&lt;/em&gt;, not being a power of 2, &lt;em&gt;reciprocal(d)&lt;/em&gt; is always a rounded value, with &lt;em&gt;0 &amp;lt; error &amp;lt; 1&lt;/em&gt;.&lt;br /&gt;
The &lt;em&gt;error&lt;/em&gt; may be calculated as follows:&lt;br /&gt;
&lt;code&gt;reciprocal(d) - 2^size / d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This rounding error is the reason, why &lt;em&gt;x * reciprocal(d)&lt;/em&gt; does not equal to &lt;em&gt;0&lt;/em&gt; if &lt;code&gt;x % d = 0&lt;/code&gt;. The higher &lt;em&gt;x&lt;/em&gt;, the higher the accumulated &lt;em&gt;error&lt;/em&gt; becomes, as the &lt;em&gt;error&lt;/em&gt; is multiplied by &lt;em&gt;x&lt;/em&gt; as well. Now it becomes clear, there is a point where the accumulated &lt;em&gt;error&lt;/em&gt; even exceeds &lt;em&gt;reciprocal(d)&lt;/em&gt;, which leads to the situation, where &lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt; does not provide the same result as &lt;code&gt;x % d == 0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;(2^size / d) / error&lt;/code&gt; (integer division) the highest &lt;em&gt;x&lt;/em&gt; may be calculated, where the proposed algorithm still provides the same result as &lt;code&gt;x % d = 0&lt;/code&gt;. Unfortunately this buys us nothing, because in my scenario &lt;em&gt;x&lt;/em&gt; may be any number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;maxuint&lt;/em&gt;. So the next question arises, what happens there or a little bit bolder: does it matter? The short answer is: no, for my use case it does not matter. Why?&lt;/p&gt;

&lt;p&gt;We could understand the proposed algorithm &lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt; as a kind of sliding window with the size of &lt;em&gt;d&lt;/em&gt;. Because we can not exactly represent the reciprocal of &lt;em&gt;d&lt;/em&gt; as whole number, the sliding window is a little bit bigger than &lt;em&gt;d&lt;/em&gt;. This leads to a difference between the proposed algorithm and the exact calculation, but the proposed algorithm still fulfills the requirement of selecting approximately every nth element (respectively every *d*th).&lt;/p&gt;

&lt;h3 id=&#34;applied-verification:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Applied verification&lt;/h3&gt;

&lt;p&gt;The verify the above statements, I wrote a small program, called &lt;a href=&#34;https://github.com/breml/zeroremainder&#34; target=&#34;_blank&#34;&gt;zeroremainder&lt;/a&gt; available at Github.&lt;/p&gt;

&lt;p&gt;This program allows to compare the results of the proposed algorithm with the result of the exact method (modulo operation) and calculate the difference of the results.&lt;/p&gt;

&lt;p&gt;As I am primarily interested in the results on 32 bit data types and for divisors between 1 and 2000, my applied verification was focused on these parameters, while the &lt;em&gt;zeroremainder&lt;/em&gt; test program does allow to check other number ranges as well.&lt;/p&gt;

&lt;h4 id=&#34;results:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Results&lt;/h4&gt;

&lt;p&gt;I ran &lt;code&gt;zeroremainder&lt;/code&gt; on my 4 core i5 2.67 GHz for about 60 hours, using 100% CPU, to fully calculate the divisors from 2 to 10000 (inclusive) with dividends from 0 to 2^32-1.&lt;/p&gt;

&lt;p&gt;Executed command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;zeroremainder -outputalldivisors -dividendend=0xffffffff -divisorend=10000 &amp;gt; 0_to_0xffffffff_2_to_10000_alldivisors.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results of these calculations are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The proposed algorithm returns in 9988 cases the same count of return value = &lt;em&gt;true&lt;/em&gt; (and respectively &lt;em&gt;false&lt;/em&gt;) as the exact method &lt;code&gt;x % d == 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the other 12 cases (divisors: 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369), the difference of the counts of return value = &lt;em&gt;true&lt;/em&gt; is exactly 1, which leads to an inaccuracy below 0.001%.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For easier verification of the results I sorted these by divisor and added a column with an exact value for the difference between the proposed algorithm and the modulo operation as a percent value as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;cat 0_to_0xffffffff_2_to_10000_alldivisors.txt | sort -n -k 2 | awk &#39; {print $0 &amp;quot; Difference exact (%): &amp;quot; sprintf(&amp;quot;%.16f&amp;quot;, 100-100/$8*$5)}&#39; &amp;gt; 0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may download these results as compressed bz2 archive &lt;a href=&#34;https://breml.github.io/downloads/0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2&#34;&gt;0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;benchmarks:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Benchmarks&lt;/h4&gt;

&lt;p&gt;To get a feeling about the performance difference of the different algorithms I implemented a small go benchmark.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ go test -bench=.        
testing: warning: no tests to run
PASS
BenchmarkDivisionMod-4        	100000000	        11.1 ns/op
BenchmarkDivisionPow2-4       	300000000	         4.21 ns/op
BenchmarkZeroremainderUint32-4	300000000	         4.46 ns/op
BenchmarkZeroremainderUint64-4	300000000	         4.50 ns/op
BenchmarkDivisionLt-4         	500000000	         3.34 ns/op
ok  	_/home/lubr/go/src/github.com/breml/zeroremainder	8.439s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am aware of the fact that these results are not comparable with the implementation of this calculations in BPF, but the give me a feeling about the dimensions.&lt;/p&gt;

&lt;h2 id=&#34;the-easiest-solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;The easiest solution&lt;/h2&gt;

&lt;p&gt;While working on this solution I became aware of an even easier way to do the sampling by evaluating &lt;code&gt;x &amp;lt; maxuint / d&lt;/code&gt;. The part &lt;em&gt;maxuint / d&lt;/em&gt; may be calculated at initialization (like &lt;em&gt;reciprocal(d)&lt;/em&gt;), where &lt;em&gt;maxuint&lt;/em&gt; is the maximum number generated by the random number generator.&lt;/p&gt;

&lt;p&gt;With this solution a simple comparison is enough to determine if a packet should be sampled or not.&lt;/p&gt;

&lt;p&gt;This solution may be used, if the source for the random numbers guarantees for a even distribution of the random numbers throughout the whole range of possible numbers.&lt;/p&gt;

&lt;h2 id=&#34;disclaimer:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Disclaimer&lt;/h2&gt;

&lt;p&gt;This document is a compilation of observations and empirical studies of the described algorithm and by no means a formal proof.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://breml.github.io/about/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/about/</guid>
      <description>

&lt;h2 id=&#34;who-i-am:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Who I am&lt;/h2&gt;

&lt;p&gt;My name is Lucas Bremgartner. In cyberspace I mostly use my nick name &lt;strong&gt;breml&lt;/strong&gt;. I life with my wife and two childern in Switzerland. I have a batchelor degree in information technology and a master of applied science degree in information security and I have more than 20 years experience in IT.&lt;/p&gt;

&lt;p&gt;But IT is not everything. One of the most important things about me is &lt;a href=&#34;http://www.the4points.com/uk/&#34; target=&#34;_blank&#34;&gt;♥ ❌ ✝ ?&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-i-do:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;What I do&lt;/h2&gt;

&lt;p&gt;I currently work as an software architect for a swiss sofware company focusing on security solutions, mainly in the fields of networks and web applications. My day to day work includes designing and planing of software products and it solutions as well as DevOps like activities. This includes solutions based on &lt;a href=&#34;https://www.elastic.co/products/elasticsearch&#34; target=&#34;_blank&#34;&gt;Elasticsearch&lt;/a&gt;, &lt;a href=&#34;https://www.elastic.co/products/logstash&#34; target=&#34;_blank&#34;&gt;Logstash&lt;/a&gt;, &lt;a href=&#34;https://graphite.readthedocs.org/&#34; target=&#34;_blank&#34;&gt;Graphite&lt;/a&gt; and &lt;a href=&#34;https://puppetlabs.com/&#34; target=&#34;_blank&#34;&gt;Puppet&lt;/a&gt;. Unfortunately a lot of the glue code, we use to put these pieces together, is closed source.&lt;/p&gt;

&lt;h2 id=&#34;open-source:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Open Source&lt;/h2&gt;

&lt;p&gt;My story with open source software starts during my education, when I did my first steps with &lt;a href=&#34;https://www.kernel.org/&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;, &lt;a href=&#34;https://www.php.net&#34; target=&#34;_blank&#34;&gt;PHP&lt;/a&gt; and &lt;a href=&#34;https://www.mysql.com&#34; target=&#34;_blank&#34;&gt;MySQL&lt;/a&gt;. My first open source contribution dates back in 1999 where I helped with a small fix to the solaris build of &lt;a href=&#34;http://www.modssl.org/about/credits.html&#34; target=&#34;_blank&#34;&gt;mod_ssl&lt;/a&gt;. Ever since I contributed to several open source projects in multiple programming languages like golang, java, php, python and ruby. Some of my last recent contributions may be found on Github as &lt;a href=&#34;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=author%3Abreml+&amp;amp;type=Issues&amp;amp;ref=searchresults&#34; target=&#34;_blank&#34;&gt;PR and issues&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Actually &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt; is my first choice. I realy love the strong typing, fast compile times, static binaries, concurrency, go gettable libraries and the mascot gopher 
&lt;img class=&#34;emoji smiley&#34; src=&#34;https://breml.github.io/img/emoji-cheat-sheet.com/public/graphics/emojis/smiley.png&#34; /&gt;

.&lt;/p&gt;

&lt;h2 id=&#34;contact:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Contact&lt;/h2&gt;

&lt;p&gt;Find my on the social networks linked on the left or send me an email:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;echo &#39;jdq,zwvnf(!zeqo&#39; | tr &#39;vdwqo,j(fnez!&#39; &#39;bu@chalmer.si&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>License</title>
      <link>https://breml.github.io/license/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/license/</guid>
      <description>

&lt;p&gt;The content of this website / blog is unless otherwise stated licensed under a &lt;a href=&#34;http://creativecommons.org/licenses/by/4.0/&#34; target=&#34;_blank&#34;&gt;Creative Commons Attribution 4.0 International License&lt;/a&gt;
&lt;a href=&#34;http://creativecommons.org/licenses/by/4.0/&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://i.creativecommons.org/l/by/4.0/80x15.png&#34; alt=&#34;Creative Commons Attribution 4.0 International License&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;used-components:53e892b8b41cc4caece1cfd5ef21d6e7&#34;&gt;Used components:&lt;/h2&gt;

&lt;p&gt;Powered by: &lt;a href=&#34;http://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/spf13/hugo/master/LICENSE.md&#34; target=&#34;_blank&#34;&gt;Simple Public License (SimPL) 2.0 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Template based on: &lt;a href=&#34;https://github.com/zyro/hyde-x&#34; target=&#34;_blank&#34;&gt;Hyde-X&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/zyro/hyde-x/master/LICENSE&#34; target=&#34;_blank&#34;&gt;MIT License&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Source code highlighting: &lt;a href=&#34;https://highlightjs.org/&#34; target=&#34;_blank&#34;&gt;highlightjs&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/isagalaev/highlight.js/master/LICENSE&#34; target=&#34;_blank&#34;&gt;License&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Emoji icons from: &lt;a href=&#34;http://www.emoji-cheat-sheet.com/&#34; target=&#34;_blank&#34;&gt;emoji-cheet-sheet.com&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/arvida/emoji-cheat-sheet.com/master/LICENSE&#34; target=&#34;_blank&#34;&gt;License&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gogitignore</title>
      <link>https://breml.github.io/blog/2015/10/06/gogitignore/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/06/gogitignore/</guid>
      <description>

&lt;p&gt;The other day I extended one of my go (golang) project with some new main packages resulting in new commands. After building the project with &lt;code&gt;go build&lt;/code&gt; the resulting executables are placed in the respective directories within the project. While updating the git repository I found it cumbersome to add all the new executables to the .gitignore-file. On linux there is unfortunately now easy way to exclude all executables within a project with a single line in .gitignore.&lt;/p&gt;

&lt;p&gt;With go it is easily predictable how the resulting executables from a main package are named. The directory name, containing a main package, will be used as filename for the new command. Hence I hacked some lines of go code to automatically update the .gitignore file. The result is the &lt;a href=&#34;https://github.com/breml/gogitignore&#34; target=&#34;_blank&#34;&gt;gogitignore&lt;/a&gt;. At the moment it still a bit rough around the edges, but the main idea is already implemented.&lt;/p&gt;

&lt;h2 id=&#34;usage:82ed5a67ff3dec1227a0a5d6b8aae203&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;In the easiest case you may just run &lt;code&gt;gogitignore&lt;/code&gt; in the root directory of your go project. This will add all executables, build from the main packages, automatically as an entry to the .gitignore file in the project root directory. To double check the result gogitignore provides the flag -stdout (or -dryrun).&lt;/p&gt;

&lt;p&gt;For more information about the usage run &lt;code&gt;gogitignore -h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-dir=&amp;quot;.&amp;quot;: destination directory where .gitignore is located and where to traverse directory tree for go programs.
-dryrun=false: dryrun, no changes are made
-exec=false: find all files with executable bit set
-gomain=true: add executables, resulting from building go main packages
-h=false: print usage
-help=false: print usage
-inplace=false: edit .gitignore in place
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>