<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elasticsearch on breml&#39;s blog</title>
    <link>https://breml.github.io/categories/elasticsearch/</link>
    <description>Recent content in Elasticsearch on breml&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Sep 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://breml.github.io/categories/elasticsearch/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Comment Elasticsearch Mapping</title>
      <link>https://breml.github.io/blog/2016/09/12/comment-elasticsearch-mapping/</link>
      <pubDate>Mon, 12 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2016/09/12/comment-elasticsearch-mapping/</guid>
      <description>&lt;p&gt;If you have worked with large &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html&#34; target=&#34;_blank&#34;&gt;Elasticsearch mappings&lt;/a&gt; you may also have encountered the problem, that there is no possibility to comment your mapping or &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html&#34; target=&#34;_blank&#34;&gt;indexing template&lt;/a&gt;. Unfortunately the Elasticsearch mappings as well as the indexing templates are defined in JSON, which does not allow to add comments.&lt;/p&gt;

&lt;p&gt;I thought the same, until I stumbled over &lt;a href=&#34;https://github.com/elastic/elasticsearch/issues/1394&#34; target=&#34;_blank&#34;&gt;Elasticsearch issue 1394&lt;/a&gt; and the linked &lt;a href=&#34;https://github.com/elastic/elasticsearch/commit/6f7253c5242e7fb94d959ce291c88f93887e3bde&#34; target=&#34;_blank&#34;&gt;commit from January 2013&lt;/a&gt;, where a single line was added to the the configuration of the JSON factory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;jsonFactory.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Could it really be true? Are there comments supported in Elasticsearch mappings?&lt;/p&gt;

&lt;p&gt;Elasticsearch uses the JSON parser from &lt;a href=&#34;https://github.com/FasterXML&#34; target=&#34;_blank&#34;&gt;FasterXML&lt;/a&gt;. The supported features of the FasterXML JSON parser are documented on a &lt;a href=&#34;https://github.com/FasterXML/jackson-core/wiki/JsonParser-Features&#34; target=&#34;_blank&#34;&gt;wiki page&lt;/a&gt; on GitHub. On this page, the feature &lt;code&gt;ALLOW_COMMENTS&lt;/code&gt; is described as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ALLOW_COMMENTS (default: false) (for textual formats with concept of comments)&lt;br /&gt;
For textual formats that do not have official comments, but for which &amp;ldquo;de facto&amp;rdquo; conventions exist (like JSON), determines whether use of such unofficial comments is allowed or not&lt;br /&gt;
Supported for: JSON&lt;br /&gt;
For JSON: enabling the feature allows recognition and handling of &amp;ldquo;C comments&amp;rdquo; (/* &amp;hellip; */) and &amp;ldquo;C++ comments&amp;rdquo; (// &amp;hellip;.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;YES!&lt;/strong&gt; Exactly what we where looking for. The commenting of Elasticsearch mappings does work well with some exceptions. Until now I found the following limitations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Comments at the head of the JSON document, before the first opening &lt;code&gt;{&lt;/code&gt;-bracket are not working&lt;/li&gt;
&lt;li&gt;Single line comments with &lt;code&gt;//&lt;/code&gt; only work at the end of the JSON document (after the closing &lt;code&gt;}&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But these limitations are minor and easily worked a round.&lt;/p&gt;

&lt;p&gt;To make it easier for others to find out about the possibility to comment Elasticsearch mappings, I filed an &lt;a href=&#34;https://github.com/elastic/elasticsearch/issues/20513&#34; target=&#34;_blank&#34;&gt;issue #20513&lt;/a&gt; on Github.&lt;/p&gt;

&lt;p&gt;Example with comments from &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html&#34; target=&#34;_blank&#34;&gt;Elasticsearch documentation&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;{
  /* mapping, used for all indices prefixed with &amp;quot;te&amp;quot; */
  &amp;quot;template&amp;quot;: &amp;quot;te*&amp;quot;,
  &amp;quot;settings&amp;quot;: {
    /* only 1 shard is needed */
    &amp;quot;number_of_shards&amp;quot;: 1
  },
  &amp;quot;mappings&amp;quot;: {
    &amp;quot;type1&amp;quot;: {
      &amp;quot;_source&amp;quot;: {
        /* source not needed */
        &amp;quot;enabled&amp;quot;: false
      },
      &amp;quot;properties&amp;quot;: {
        &amp;quot;host_name&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
          /* host_name is used as filter, do not analyze */
          &amp;quot;index&amp;quot;: &amp;quot;not_analyzed&amp;quot;
        },
        &amp;quot;created_at&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot;,
          &amp;quot;format&amp;quot;: &amp;quot;EEE MMM dd HH:mm:ss Z YYYY&amp;quot;
        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tagging of dynamically added Fields in Elasticsearch</title>
      <link>https://breml.github.io/blog/2015/10/28/tagging-of-dynamically-added-fields-in-elasticsearch/</link>
      <pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/28/tagging-of-dynamically-added-fields-in-elasticsearch/</guid>
      <description>

&lt;p&gt;At work we use the ELK Stack (Elasticsearch, Logstash and Kibana) to process, store and visualize all kind of log data. To get the most out of the information stored in Elasticsearch, we maintain a handcrafted Elasticsearch mapping.&lt;/p&gt;

&lt;p&gt;As we are in the process of continuously adding more and more log sources, now and then our Elasticsearch mapping is not complete. In this case the dynamic mapping feature of Elasticsearch adds these new fields by it&amp;rsquo;s own.&lt;/p&gt;

&lt;p&gt;As we want to keep our Elasticsearch mapping up to date we have been looking for an easy way to identify all the new fields dynamically added.&lt;/p&gt;

&lt;h2 id=&#34;naive-approach:21bceea47ef0daa27dbdfefe21d795ad&#34;&gt;Naive approach&lt;/h2&gt;

&lt;p&gt;The naive approach to find the differences between our handcrafted mapping and the actual mapping, used by Elasticsearch for the respective index (possibly with dynamically added fields), would be a simple &lt;code&gt;diff&lt;/code&gt; of two text files.&lt;/p&gt;

&lt;p&gt;The handcrafted mapping is stored as a simple JSON-file, which is used by Logstash to apply the mapping when a new index is created.&lt;/p&gt;

&lt;p&gt;The active mapping is accessible via the Elasticsearch API, for example with &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/logstash-2015.10.28/_mapping&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is, these two files are not directly comparable, for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are not equally formated (may be corrected by tools like &lt;code&gt;jq&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;They do not necessarily include the same settings for the defined fields, as Elasticsearch does not provide settings, which are set to the default value and our handcrafted mapping may include settings which are the default value&lt;/li&gt;
&lt;li&gt;The order of the attributes may not necessarily be the same&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So it is obvious a naive &lt;code&gt;diff&lt;/code&gt; of the two files does not lead the goal, even if we ensure the same formating for both files by using a tool like &lt;a href=&#34;https://stedolan.github.io/jq/&#34; target=&#34;_blank&#34;&gt;jq&lt;/a&gt;. Even if we use JSON aware tools to find the differences, like &lt;a href=&#34;http://json-delta.readthedocs.org/en/latest/&#34; target=&#34;_blank&#34;&gt;json-delta&lt;/a&gt;, we do not get the right result as these tools are not able to determine, where field settings are included in the handcrafted mapping file, which are set to the default value.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-field-template-and-custom-field-analyzer:21bceea47ef0daa27dbdfefe21d795ad&#34;&gt;Dynamic field template and custom field analyzer&lt;/h2&gt;

&lt;p&gt;So we looked for an other way to achieve the goal and we came up with the following solution.&lt;/p&gt;

&lt;p&gt;Elasticsearch does provide two features, which combined provide a easy solution to identify all dynamically added fields:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Elasticsearch allows to define the dynamic mapping, which is used, if a certain field is not currently present in the mapping&lt;/li&gt;
&lt;li&gt;Elasticsearch allows to define custom analyzers, used to analyze the content of a field in a certain way.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we did is defining a custom analyzer called &lt;em&gt;unknown_field_analyzer&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;template&amp;quot; : &amp;quot;logstash-*&amp;quot;,
  &amp;quot;settings&amp;quot; : {
    &amp;quot;analysis&amp;quot; : {
      &amp;quot;analyzer&amp;quot; : {
        &amp;quot;unknown_field_analyzer&amp;quot; : {
          &amp;quot;type&amp;quot; : &amp;quot;whitespace&amp;quot;
        }
      }
    }
  }
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(snipped of &lt;em&gt;analyzers&lt;/em&gt; section of the Elasticsearch mapping)&lt;/p&gt;

&lt;p&gt;This analyzer we apply in the definition for the dynamic templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;dynamic_templates&amp;quot; : [
    {
      &amp;quot;string_fields&amp;quot; : {
        &amp;quot;mapping&amp;quot; : {
          &amp;quot;index&amp;quot; : &amp;quot;analyzed&amp;quot;,
          &amp;quot;omit_norms&amp;quot; : true,
          &amp;quot;analyzer&amp;quot; : &amp;quot;unknown_field_analyzer&amp;quot;,
          &amp;quot;type&amp;quot; : &amp;quot;string&amp;quot;
        },
        &amp;quot;match_mapping_type&amp;quot; : &amp;quot;string&amp;quot;,
        &amp;quot;match&amp;quot; : &amp;quot;*&amp;quot;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(snipped of _dynamic&lt;em&gt;templates&lt;/em&gt; section of the Elasticsearch mapping)&lt;/p&gt;

&lt;p&gt;This leads to the a mapping, where all dynamically added fields are doubtless identified by the setting &lt;em&gt;analyzer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now it is easy to list all dynamically added fields by a small script, using the already mentioned tool &lt;code&gt;jq&lt;/code&gt; (requires at least version 1.5):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/logstash-2015.10.28/_mapping&#39; 2&amp;gt;/dev/null | jq &#39;.[].mappings | to_entries | .[] | .key as $mapping | .value.properties | to_entries | .[] | .key as $property | if .value.analyzer? == &amp;quot;unknown_field_analyzer&amp;quot; then &amp;quot;mapping: &amp;quot; + $mapping + &amp;quot;, property: &amp;quot; + $property else empty end&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script returns the following example output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;mapping: mylog, property: newfield&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the main idea of the above script a monitoring system could easily alert if new fields have been dynamically added.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>