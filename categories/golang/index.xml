<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on breml&#39;s blog</title>
    <link>https://breml.github.io/categories/golang/</link>
    <description>Recent content in Golang on breml&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://breml.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Deploy a Go Web App to the Swisscom Application Cloud</title>
      <link>https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/</link>
      <pubDate>Thu, 17 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/</guid>
      <description>

&lt;p&gt;Inspired by the &lt;a href=&#34;https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;this blog post&lt;/a&gt; about the deployment of a &lt;a href=&#34;https://nodejs.org&#34; target=&#34;_blank&#34;&gt;node.js&lt;/a&gt; example app to the &lt;a href=&#34;http://developer.swisscom.com/&#34; target=&#34;_blank&#34;&gt;Swisscom Application Cloud&lt;/a&gt;, I decided to test the Swisscom Application Cloud my self with a similar app, written in Google &lt;a href=&#34;https://golang.org&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt; language.&lt;/p&gt;

&lt;p&gt;This blog should take you through the essential steps on a Linux based system to push your own Go based app to a &lt;a href=&#34;https://www.cloudfoundry.org&#34; target=&#34;_blank&#34;&gt;Cloud Foundry&lt;/a&gt; based app cloud, for example the one from Swisscom.&lt;/p&gt;

&lt;h2 id=&#34;preparations:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Preparations&lt;/h2&gt;

&lt;h3 id=&#34;go-development-environment:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Go development environment&lt;/h3&gt;

&lt;p&gt;I assume you already have a prepared Go development environment. Otherwise I suggest you to start with the &lt;a href=&#34;https://golang.org/doc/install&#34; target=&#34;_blank&#34;&gt;Getting Started&lt;/a&gt; manual.&lt;/p&gt;

&lt;p&gt;To check, if you have the go tool chain ready, just enter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this should print something like the below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOARCH=&amp;quot;amd64&amp;quot;
GOBIN=&amp;quot;&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;quot;amd64&amp;quot;
GOHOSTOS=&amp;quot;linux&amp;quot;
GOOS=&amp;quot;linux&amp;quot;
GOPATH=&amp;quot;/home/user/go&amp;quot;
GORACE=&amp;quot;&amp;quot;
GOROOT=&amp;quot;/usr/local/go&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_amd64&amp;quot;
GO15VENDOREXPERIMENT=&amp;quot;0&amp;quot;
CC=&amp;quot;gcc&amp;quot;
GOGCCFLAGS=&amp;quot;-g -O2 -fPIC -m64 -pthread&amp;quot;
CXX=&amp;quot;g++&amp;quot;
CGO_ENABLED=&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are using Go in version 1.5.x, you may have set the environment variable &lt;code&gt;GO15VENDOREXPERIMENT=1&lt;/code&gt;. For this tutorial I suggest to switch the Go 1.5 vendor experiment off (&lt;code&gt;GO15VENDOREXPERIMENT=0&lt;/code&gt;), as this makes our deployment to the app cloud a little bit easier. (Additional information about the hitches with &lt;em&gt;godep&lt;/em&gt; and the Go 1.5 vendor experiment could be found in this &lt;a href=&#34;https://devcenter.heroku.com/articles/go-support#go-1-5-vendor-experiment&#34; target=&#34;_blank&#34;&gt;article on heroku&lt;/a&gt;.)&lt;/p&gt;

&lt;h3 id=&#34;godep:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Godep&lt;/h3&gt;

&lt;p&gt;Cloud Foundry uses so called &lt;a href=&#34;https://docs.developer.swisscom.com/apps/deploy-apps/index.html#buildpacks&#34; target=&#34;_blank&#34;&gt;buildpacks&lt;/a&gt; to provide framework and runtime support for the application. We will later use the &lt;a href=&#34;https://github.com/cloudfoundry/go-buildpack&#34; target=&#34;_blank&#34;&gt;Go buildpack&lt;/a&gt; to deploy our web app to the app cloud.&lt;/p&gt;

&lt;p&gt;In order to specify the external dependencies (external Go packages) for the Go web app, the above mentioned buildpack uses the tool &lt;a href=&#34;https://github.com/tools/godep&#34; target=&#34;_blank&#34;&gt;Godep&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The installation of Godep is quite straight forward. Just let Go do the work for us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go get github.com/tools/godep
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will place the &lt;code&gt;godep&lt;/code&gt; command in the directory &lt;code&gt;$GOPATH/bin&lt;/code&gt;. If &lt;code&gt;$GOPATH/bin&lt;/code&gt; is part of your &lt;code&gt;$PATH&lt;/code&gt;, &lt;em&gt;godep&lt;/em&gt; is now directly available as command.&lt;/p&gt;

&lt;h3 id=&#34;cloud-foundry-cli:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Cloud Foundry CLI&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/cloudfoundry/cli/&#34; target=&#34;_blank&#34;&gt;Cloud Foundry Command Line Interface (CF CLI)&lt;/a&gt; is a command line tool for deploying and managing your applications within the app cloud. You can download the CF CLI from &lt;a href=&#34;https://github.com/cloudfoundry/cli/releases/&#34; target=&#34;_blank&#34;&gt;github.com/cloudfoundry/cli/releases&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The CF CLI tool is written in Go as well and therfore consists of a single static binary. The installation is as simple as download and decompress the executable. For a 64 bit Linux systems, you could use the following commands to download the latest version (6.14.0 as of writing) and to place the executable to the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -L &#39;https://cli.run.pivotal.io/stable?release=linux64-binary&amp;amp;version=6.14.0&amp;amp;source=github-rel&#39; | tar -xz &amp;gt; cf; chmod +x cf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check if everything is working, execute &lt;code&gt;./cf help&lt;/code&gt;. For best comfort, you should move the &lt;code&gt;cf&lt;/code&gt; binary to a directory within you &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Alternatively there are installable packages for several OS available as well.&lt;/p&gt;

&lt;h2 id=&#34;create-the-go-hello-world-web-app:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Create the Go &amp;ldquo;Hello world&amp;rdquo; Web App&lt;/h2&gt;

&lt;p&gt;Now we have everything in place to get started with writing the Go version of the &amp;ldquo;Hello world&amp;rdquo; web app.&lt;/p&gt;

&lt;p&gt;First you should create a new directory named &lt;em&gt;appcloud&lt;/em&gt; within &lt;code&gt;$GOPATH/src&lt;/code&gt; and enter it. If you are a &lt;a href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;github.com&lt;/a&gt; user, a good choice would be &lt;code&gt;$GOPATH/src/github.com/&amp;lt;your github username&amp;gt;/appcloud&lt;/code&gt;. Secondly create a new file named &lt;em&gt;main.go&lt;/em&gt; with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;Hello world!&amp;quot;)
}

func main() {
	port := os.Getenv(&amp;quot;PORT&amp;quot;)
	if port == &amp;quot;&amp;quot; {
		port = &amp;quot;3000&amp;quot;
	}

	log.Printf(&amp;quot;Use port: %s\n&amp;quot;, port)

	http.HandleFunc(&amp;quot;/&amp;quot;, helloHandler)
	err := http.ListenAndServe(&amp;quot;:&amp;quot;+port, nil)
	if err != nil {
		log.Panicf(&amp;quot;ListenAndServe error: %v\n&amp;quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program is quite straight forward:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We name the package &amp;ldquo;main&amp;rdquo;, because in Go the &lt;em&gt;main&lt;/em&gt; package is the entry point for the application.&lt;/li&gt;
&lt;li&gt;We import some additional packages from the fantastic Go standard library, which will allow us to listen and answer to web requests.&lt;/li&gt;
&lt;li&gt;The function &lt;code&gt;helloHandler&lt;/code&gt; will be executed for every request to the web app and will write the famous &amp;ldquo;Hello world&amp;rdquo; to the &lt;code&gt;http.ResponseWriter&lt;/code&gt;, which will be returned to the browser of the client.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;main&lt;/code&gt; function is where our program starts and where we do some setup:

&lt;ul&gt;
&lt;li&gt;First we collect the TCP Port to bind from the environment variable &lt;code&gt;PORT&lt;/code&gt;, because this variable will be set in the app cloud the tell our web app on which TCP port we should bind. If no such environment variable is present, we default to port &lt;em&gt;3000&lt;/em&gt;. (Side note: Go expects the port to be a string, because values like &lt;code&gt;http&lt;/code&gt; as alias for port 80, are understood by Go as well)&lt;/li&gt;
&lt;li&gt;For convenience we log (defaults to stderr) the TCP port, where the web app will bind.&lt;/li&gt;
&lt;li&gt;With &lt;code&gt;http.HandleFunc(&amp;quot;/&amp;quot;, helloHandler)&lt;/code&gt; we add the function &lt;code&gt;helloHandler&lt;/code&gt; as handler function to our web server. Because this is the only handler function and we set the pattern to &lt;code&gt;/&lt;/code&gt;, every request to our web app will execute the helloHandler.&lt;/li&gt;
&lt;li&gt;The whole &amp;ldquo;start a web server&amp;rdquo; magic happens in the line &lt;code&gt;err := http.ListenAndServe(&amp;quot;:&amp;quot;+port, nil)&lt;/code&gt;. With this line our program starts an endless loop to listen on the respective TCP port, on all available IP addresses, and to execute the defined handler functions (in our case there is just one).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s it for the web app. Now let&amp;rsquo;s have a look, if every thing is working properly.&lt;/p&gt;

&lt;p&gt;We can start our web app with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go run main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just after starting you should see an output similar to the one below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;2015/12/17 10:58:38 Use port: 3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If no other output is printed out, the program is ready to serve HTTP requests. So point your web browser to &lt;a href=&#34;http://localhost:3000&#34; target=&#34;_blank&#34;&gt;http://localhost:3000&lt;/a&gt; and enjoy the &amp;ldquo;Hello world!&amp;rdquo; output.&lt;/p&gt;

&lt;h2 id=&#34;move-into-the-cloud:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Move into the Cloud&lt;/h2&gt;

&lt;p&gt;Before we can move our newly build Go based web app to the Swisscom App Cloud, we have to do some preparations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Setup a Swisscom Developer Account&lt;/li&gt;
&lt;li&gt;Specify our dependencies with Godep&lt;/li&gt;
&lt;li&gt;Create a Cloud Foundry manifest.yml&lt;/li&gt;
&lt;li&gt;Upload everything to the cloud&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;setup-a-swisscom-developer-account:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Setup a Swisscom Developer Account&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t go into all the details, because they are already outlined in this &lt;a href=&#34;https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt;.
For the brave, just head to &lt;a href=&#34;https://console.developer.swisscom.com/&#34; target=&#34;_blank&#34;&gt;Swisscom Developer Account&lt;/a&gt; and follow the instructions (you will need a credit card in order to precede).&lt;/p&gt;

&lt;h3 id=&#34;specify-our-dependencies-with-godep:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Specify our Dependencies with Godep&lt;/h3&gt;

&lt;p&gt;Even if we don&amp;rsquo;t use any external dependencies, because all used packages belong to the Go standard library, the file, describing the dependencies for our program has still to be present.&lt;/p&gt;

&lt;p&gt;This file is auto generated with the command &lt;code&gt;godep save -r&lt;/code&gt; (assuming the &lt;em&gt;godep&lt;/em&gt; command resides within the &lt;code&gt;$PATH&lt;/code&gt;). This will create a new directory named &lt;em&gt;Godeps&lt;/em&gt;. Within this directory we find a file called &lt;em&gt;Godeps.json&lt;/em&gt; with a content like to following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;ImportPath&amp;quot;: &amp;quot;github.com/breml/appcloud&amp;quot;,
	&amp;quot;GoVersion&amp;quot;: &amp;quot;go1.5&amp;quot;,
	&amp;quot;Deps&amp;quot;: []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a properly setup &lt;code&gt;$GOPATH&lt;/code&gt; and your web app for the app cloud is placed within the &lt;code&gt;$PATH/src/&lt;/code&gt;, everything should be fine.&lt;/p&gt;

&lt;p&gt;If this is not the case, for whatever reason you have to manually modify the just generated &lt;code&gt;Godeps/Godeps.json&lt;/code&gt; file in order to work with the Go buildpack. Most likely the line with &lt;code&gt;ImportPath&lt;/code&gt; reads as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;ImportPath&amp;quot;: &amp;quot;.&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the &amp;ldquo;.&amp;rdquo; has to be replaced with the directory name, where your go web app resides. If you have followed the instructions above, your directory is named &lt;em&gt;appcloud&lt;/em&gt; and you have to replace the above line with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;quot;ImportPath&amp;quot;: &amp;quot;appcloud&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-cloud-foundry-manifest-yml:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Create a Cloud Foundry manifest.yml&lt;/h3&gt;

&lt;p&gt;From the Cloud Foundry &lt;a href=&#34;https://docs.developer.swisscom.com/apps/deploy-apps/manifest.html&#34; target=&#34;_blank&#34;&gt;docs&lt;/a&gt; we learn about &lt;em&gt;manifest.yml&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The application manifest tell the &lt;code&gt;cf push&lt;/code&gt; command what to do with applications. This includes everything from how many instances to create and how much memory to allocate to what services applications should use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For our small Go web app, we need to provide the following information within the &lt;code&gt;manifest.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;---
applications:
- name: DemoApp
  memory: 64M
  host: demoapp&amp;lt;YOURNUMBER&amp;gt;
  buildpack: https://github.com/cloudfoundry/go-buildpack.git
  command: appcloud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In detail:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;name&lt;/em&gt;: name of the app within the app cloud.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;memory&lt;/em&gt;: how much memory should be provided for the app. For our small Go example the minimum setting of 64M is by far enough.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;host&lt;/em&gt;: hostname of the app. This name combined with the assigned domain will be the URL for the app (E. g. demoapp.scapp.io). You should replace &lt;code&gt;&amp;lt;YOURNUMBER&amp;gt;&lt;/code&gt; with a random number of yours. If you catch a hostname, which is already taken, you will be notified while pushing the app.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;buildpack&lt;/em&gt;: for Go apps, the recommended buildpack is the mentioned above. This provides framework and runtime support for Go apps.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;command&lt;/em&gt;: Our Go source code, including the respective dependencies managed by &lt;em&gt;Godep&lt;/em&gt;, will be compiled while pushing to the app cloud with the provided support by the buildpack. The result will be an executable. The &lt;em&gt;command&lt;/em&gt; setting tells the app cloud which program to execute.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;upload-everything-to-the-cloud:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Upload Everything to the Cloud&lt;/h3&gt;

&lt;p&gt;Now with everything set, we may login at the Swisscom App Cloud with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf login -a https://api.lyra-836.appcloud.swisscom.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and finally deploy our application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cf push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything is successful, you may now access your &amp;ldquo;Hello world&amp;rdquo; app at &lt;a href=&#34;http://demoapp&amp;lt;YOURNUMBER&amp;gt;.scapp.io/&#34; target=&#34;_blank&#34;&gt;http://demoapp&amp;lt;YOURNUMBER&amp;gt;.scapp.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;annex:eea88275f045d0df4893e61c6a42ed5d&#34;&gt;Annex&lt;/h2&gt;

&lt;p&gt;An extended version of the example, described in this blog post, may be found on &lt;a href=&#34;https://github.com/breml/appcloud&#34; target=&#34;_blank&#34;&gt;github.com/breml/appcloud&lt;/a&gt;. Commit &lt;a href=&#34;https://github.com/breml/appcloud/tree/dcb5ce9d&#34; target=&#34;_blank&#34;&gt;dcb5ce9d&lt;/a&gt; does correspond to this post.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/&#34; target=&#34;_blank&#34;&gt;original post&lt;/a&gt; you may find information about scaling your app and combining your app with services.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dividable without remainder</title>
      <link>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</link>
      <pubDate>Thu, 22 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</guid>
      <description>

&lt;h2 id=&#34;summary:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Summary&lt;/h2&gt;

&lt;h3 id=&#34;problem:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;For a &amp;ldquo;1 in n sampling&amp;rdquo; problem I was looking for a fast way to determine, if a value &lt;em&gt;x&lt;/em&gt; (random number) is dividable by a previously known divisor &lt;em&gt;d&lt;/em&gt; (sampling rate) without remainder. So the algorithm has to result with &lt;em&gt;true&lt;/em&gt; in &lt;em&gt;1&lt;/em&gt; of &lt;em&gt;d&lt;/em&gt; cases, otherwise with &lt;em&gt;false&lt;/em&gt;. &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; are both unsigned integers, in my case 32 bit long. Since the algorithm will be used for sampling and &lt;em&gt;x&lt;/em&gt; is produced by a random number generator (see below: Motivation), a slight inaccuracy (&amp;lt; 0.01%) may be tolerable. The usual range for &lt;em&gt;d&lt;/em&gt; will be whole numbers between 1 and 2000, based on the recommendations for &lt;a href=&#34;http://blog.sflow.com/2009/06/sampling-rates.html&#34; target=&#34;_blank&#34;&gt;sFlow sampling rates&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;tl;dr Solution&lt;/h3&gt;

&lt;p&gt;The obvious solution of course is to use the modulo operation: &lt;code&gt;x % d == 0&lt;/code&gt;. In my special case, the modulo operation is not available, and I therefore had to look for an alternative (for details see: Motivation).&lt;/p&gt;

&lt;p&gt;The proposed solution only works with positive (unsigned) values.&lt;br /&gt;
&lt;em&gt;d = 0&lt;/em&gt; is not allowed (division by 0); for &lt;em&gt;d = 1&lt;/em&gt;, the result is always true.&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;d&lt;/em&gt; is a power of 2 (e.g. 4, 8, 16), the result is determined with &lt;code&gt;x &amp;amp; (d - 1) == 0&lt;/code&gt;. If true, there is no remainder.&lt;/p&gt;

&lt;p&gt;For all other cases, the following calculation is performed:&lt;br /&gt;
&lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt;&lt;br /&gt;
The reciprocal function is defined as:&lt;br /&gt;
&lt;code&gt;reciprocal(d) = maxuint / d + 1&lt;/code&gt;&lt;br /&gt;
where the division is an integer division, where the result is round down.&lt;br /&gt;
&lt;em&gt;maxuint&lt;/em&gt; is the maximum unsigned integer value of the used data type, in my case 32 bit (&lt;em&gt;maxuint = 2^32 - 1 = 4294967295&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;The check, if &lt;em&gt;d&lt;/em&gt; is a power of 2 and the calculation of &lt;em&gt;reciprocal(d)&lt;/em&gt; is performed only once at initialization, because the sampling-rate is constant during the whole sampling process.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;x&lt;/em&gt; in 0 to &lt;em&gt;maxuint&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; from 1 to 10000 (inclusive) the proposed algorithm returns in 9988 cases the same count of return value = &lt;em&gt;true&lt;/em&gt; (and respectively &lt;em&gt;false&lt;/em&gt;) as the exact method &lt;code&gt;x % d == 0&lt;/code&gt;. In the other 12 cases, the difference of the counts of return value = &lt;em&gt;true&lt;/em&gt; is 1, which leads to an inaccuracy below 0.001%.&lt;/p&gt;

&lt;p&gt;These results are verified by a small program of mine, called &lt;a href=&#34;https://github.com/breml/zeroremainder&#34; target=&#34;_blank&#34;&gt;zeroremainder&lt;/a&gt; available at Github.&lt;/p&gt;

&lt;h3 id=&#34;bottom-line:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Bottom Line&lt;/h3&gt;

&lt;p&gt;The proposed algorithm is usable for the use case in question, as the difference of the results compared to the exact method, using the modulo operation, is marginal (below 0.001%).&lt;/p&gt;

&lt;h2 id=&#34;motivation:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;I am working on a tool, to sample network packets at arbitrary sampling rate (normally between 1 and 2000), as proposed by &lt;a href=&#34;http://www.sflow.org&#34; target=&#34;_blank&#34;&gt;sFlow&lt;/a&gt;). My implementation is based on &lt;a href=&#34;https://github.com/google/gopacket&#34; target=&#34;_blank&#34;&gt;gopacket&lt;/a&gt;, which uses libpcap, the same library used by &lt;a href=&#34;http://www.tcpdump.org/&#34; target=&#34;_blank&#34;&gt;tcpdump&lt;/a&gt;. One of my approaches for the sampling of the packages is based on &lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/filter.txt&#34; target=&#34;_blank&#34;&gt;BPF (Berkeley Packet Filter)&lt;/a&gt;, which allows to filter the captured packets in the kernel. The assumption is that filtering in kernel mode should be faster, because there are less context switches and memory copy operations necessary. BPF allows to call the &lt;em&gt;prandom&lt;/em&gt; interface of the kernel to get a random uint32 number. One way to decide, if the current packet should be sampled, is to use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Modulo_operation&#34; target=&#34;_blank&#34;&gt;modulo&lt;/a&gt; operation; random number modulo sampling rate. If the remainder is 0, the packet is sampled, otherwise the packet is ignored.&lt;/p&gt;

&lt;p&gt;Although BPF assembler does provide a modulo instruction, I do not want to use this instruction because of two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The modulo BPF instruction is not supported with libpcap &amp;lt; 1.6.0&lt;/li&gt;
&lt;li&gt;Unsigned integer division (and therefore modulo) is one of the slowest operations on a modern microprocessor (see benchmark results below)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;inspiration:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Inspiration&lt;/h2&gt;

&lt;p&gt;While searching the web for possible solutions, which could be implemented easily in assembler, I stumbled over &lt;a href=&#34;https://courses.engr.illinois.edu/ece390/books/artofasm/CH09/CH09-6.html#HEADING6-39&#34; target=&#34;_blank&#34;&gt;Division Without DIV and IDIV&lt;/a&gt; and the concept of magic numbers (&lt;a href=&#34;http://stackoverflow.com/a/2661840&#34; target=&#34;_blank&#34;&gt;Stackoverflow - Most optimized way to calculate modulus in C&lt;/a&gt;, &lt;a href=&#34;http://www.hackersdelight.org/magic.htm&#34; target=&#34;_blank&#34;&gt;Magic number generator&lt;/a&gt;, &lt;a href=&#34;http://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html&#34; target=&#34;_blank&#34;&gt;Labor of Division&lt;/a&gt;) which replaces division by a multiplication with a magic number and a binary shift operation.&lt;/p&gt;

&lt;p&gt;Inspired by this ideas I started to experiment with reciprocal, magic numbers and overflow of unsigned integers.&lt;/p&gt;

&lt;h2 id=&#34;solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;preconditions:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Preconditions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;We only work with unsigned integers, where the &lt;em&gt;size&lt;/em&gt; of the integer is a multiple of 8 (bits), normally one of 8, 16, 32, 64 (depending on data type and architecture)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;maxuint&lt;/em&gt; is defined as: &lt;code&gt;maxuint = 2^size - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The divisor &lt;em&gt;d&lt;/em&gt; must not be &lt;em&gt;0&lt;/em&gt; (would lead to division by 0 error)&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;d&lt;/em&gt; is &lt;em&gt;1&lt;/em&gt;, no calculation is performed, the result is always &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The dividend &lt;em&gt;x&lt;/em&gt; may be any number in the range from &lt;em&gt;0&lt;/em&gt; to &lt;em&gt;maxuint&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;d-being-a-power-of-2:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;&lt;strong&gt;d&lt;/strong&gt; being a power of 2&lt;/h3&gt;

&lt;p&gt;This part of the solution is straightforward. If &lt;em&gt;d&lt;/em&gt; is a power of 2 (e.g. 4, 8, 16), the modulo could by determined with a simple &lt;em&gt;and&lt;/em&gt; operation, &lt;code&gt;x &amp;amp; (d - 1) == 0&lt;/code&gt;. The result of a bitwise &lt;em&gt;and&lt;/em&gt;-operation of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d - 1&lt;/em&gt; is the remainder. Therefore if the result is 0, there is no remainder and the equation is &lt;em&gt;true&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;multiply-by-reciprocal:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Multiply by reciprocal&lt;/h3&gt;

&lt;p&gt;For all other cases (&lt;em&gt;d&lt;/em&gt; not being a power of 2), the basic idea is, to perform a multiplication of &lt;em&gt;x&lt;/em&gt; and the reciprocal of &lt;em&gt;d&lt;/em&gt;, calculated on the base of &lt;em&gt;maxuint&lt;/em&gt;, the maximum integer value of respective data type or architecture (e.g. 32 bit), and use the &lt;em&gt;free&lt;/em&gt; wrap around modulo operation of the integer overflow. The integer overflow is described in &lt;a href=&#34;https://en.wikipedia.org/wiki/Integer_overflow&#34; target=&#34;_blank&#34;&gt;Wikipedia - Integer overflow&lt;/a&gt; as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Since an arithmetic operation may produce a result larger than the maximum representable value, a potential error condition may result. In the C programming language, signed integer overflow causes undefined behavior, while unsigned integer overflow causes the number to be reduced modulo a power of two, meaning that unsigned integers &amp;ldquo;wrap around&amp;rdquo; on overflow.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First we handle some special cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;x == 0&lt;/em&gt; the result is always &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;0 &amp;lt; x &amp;lt; d&lt;/em&gt; no calculation is performed as the result has to be false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The elimination of these special cases ensures that a wrap around modulo operation is always performed.&lt;/p&gt;

&lt;p&gt;For the remaining cases (&lt;em&gt;x &amp;gt; d&lt;/em&gt;) the following calculation is performed to decide if a packet should be sampled or not:&lt;br /&gt;
&lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The used reciprocal is calculated as rounded up division of &lt;em&gt;maxuint&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt;, the division being an integer division, where the result is round down):&lt;br /&gt;
&lt;code&gt;reciprocal(d) = maxuint / d + 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;One of the first question I asked my self about this equation was, why has &lt;em&gt;x * reciprocal(d)&lt;/em&gt; to be smaller than &lt;em&gt;reciprocal(d)&lt;/em&gt;?  To explain this, let&amp;rsquo;s have a look at an example with &lt;em&gt;d&lt;/em&gt; being a power of 2. We know, if &lt;em&gt;d&lt;/em&gt; is a power of 2, there is a simpler approach to determine, if a &lt;em&gt;x&lt;/em&gt; is dividable by &lt;em&gt;d&lt;/em&gt; without remainder, by using the bitwise &lt;em&gt;and&lt;/em&gt;-operation described above.&lt;br /&gt;
Nevertheless we may use the proposed algorithm. In this case &lt;em&gt;x * reciprocal(d)&lt;/em&gt; will always result to &lt;em&gt;0&lt;/em&gt;, if &lt;em&gt;x&lt;/em&gt; is dividable by &lt;em&gt;d&lt;/em&gt; without remainder. This works because in this case &lt;em&gt;reciprocal(d)&lt;/em&gt; results in the effective reciprocal value of d, without rounding error. For all other &lt;em&gt;d&lt;/em&gt;, not being a power of 2, &lt;em&gt;reciprocal(d)&lt;/em&gt; is always a rounded value, with &lt;em&gt;0 &amp;lt; error &amp;lt; 1&lt;/em&gt;.&lt;br /&gt;
The &lt;em&gt;error&lt;/em&gt; may be calculated as follows:&lt;br /&gt;
&lt;code&gt;reciprocal(d) - 2^size / d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This rounding error is the reason, why &lt;em&gt;x * reciprocal(d)&lt;/em&gt; does not equal to &lt;em&gt;0&lt;/em&gt; if &lt;code&gt;x % d = 0&lt;/code&gt;. The higher &lt;em&gt;x&lt;/em&gt;, the higher the accumulated &lt;em&gt;error&lt;/em&gt; becomes, as the &lt;em&gt;error&lt;/em&gt; is multiplied by &lt;em&gt;x&lt;/em&gt; as well. Now it becomes clear, there is a point where the accumulated &lt;em&gt;error&lt;/em&gt; even exceeds &lt;em&gt;reciprocal(d)&lt;/em&gt;, which leads to the situation, where &lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt; does not provide the same result as &lt;code&gt;x % d == 0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;(2^size / d) / error&lt;/code&gt; (integer division) the highest &lt;em&gt;x&lt;/em&gt; may be calculated, where the proposed algorithm still provides the same result as &lt;code&gt;x % d = 0&lt;/code&gt;. Unfortunately this buys us nothing, because in my scenario &lt;em&gt;x&lt;/em&gt; may be any number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;maxuint&lt;/em&gt;. So the next question arises, what happens there or a little bit bolder: does it matter? The short answer is: no, for my use case it does not matter. Why?&lt;/p&gt;

&lt;p&gt;We could understand the proposed algorithm &lt;code&gt;x * reciprocal(d) &amp;lt; reciprocal(d)&lt;/code&gt; as a kind of sliding window with the size of &lt;em&gt;d&lt;/em&gt;. Because we can not exactly represent the reciprocal of &lt;em&gt;d&lt;/em&gt; as whole number, the sliding window is a little bit bigger than &lt;em&gt;d&lt;/em&gt;. This leads to a difference between the proposed algorithm and the exact calculation, but the proposed algorithm still fulfills the requirement of selecting approximately every nth element (respectively every *d*th).&lt;/p&gt;

&lt;h3 id=&#34;applied-verification:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Applied verification&lt;/h3&gt;

&lt;p&gt;The verify the above statements, I wrote a small program, called &lt;a href=&#34;https://github.com/breml/zeroremainder&#34; target=&#34;_blank&#34;&gt;zeroremainder&lt;/a&gt; available at Github.&lt;/p&gt;

&lt;p&gt;This program allows to compare the results of the proposed algorithm with the result of the exact method (modulo operation) and calculate the difference of the results.&lt;/p&gt;

&lt;p&gt;As I am primarily interested in the results on 32 bit data types and for divisors between 1 and 2000, my applied verification was focused on these parameters, while the &lt;em&gt;zeroremainder&lt;/em&gt; test program does allow to check other number ranges as well.&lt;/p&gt;

&lt;h4 id=&#34;results:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Results&lt;/h4&gt;

&lt;p&gt;I ran &lt;code&gt;zeroremainder&lt;/code&gt; on my 4 core i5 2.67 GHz for about 60 hours, using 100% CPU, to fully calculate the divisors from 2 to 10000 (inclusive) with dividends from 0 to 2^32-1.&lt;/p&gt;

&lt;p&gt;Executed command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;zeroremainder -outputalldivisors -dividendend=0xffffffff -divisorend=10000 &amp;gt; 0_to_0xffffffff_2_to_10000_alldivisors.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results of these calculations are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The proposed algorithm returns in 9988 cases the same count of return value = &lt;em&gt;true&lt;/em&gt; (and respectively &lt;em&gt;false&lt;/em&gt;) as the exact method &lt;code&gt;x % d == 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the other 12 cases (divisors: 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369), the difference of the counts of return value = &lt;em&gt;true&lt;/em&gt; is exactly 1, which leads to an inaccuracy below 0.001%.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For easier verification of the results I sorted these by divisor and added a column with an exact value for the difference between the proposed algorithm and the modulo operation as a percent value as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;cat 0_to_0xffffffff_2_to_10000_alldivisors.txt | sort -n -k 2 | awk &#39; {print $0 &amp;quot; Difference exact (%): &amp;quot; sprintf(&amp;quot;%.16f&amp;quot;, 100-100/$8*$5)}&#39; &amp;gt; 0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may download these results as compressed bz2 archive &lt;a href=&#34;https://breml.github.io/downloads/0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2&#34;&gt;0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;benchmarks:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Benchmarks&lt;/h4&gt;

&lt;p&gt;To get a feeling about the performance difference of the different algorithms I implemented a small go benchmark.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ go test -bench=.        
testing: warning: no tests to run
PASS
BenchmarkDivisionMod-4        	100000000	        11.1 ns/op
BenchmarkDivisionPow2-4       	300000000	         4.21 ns/op
BenchmarkZeroremainderUint32-4	300000000	         4.46 ns/op
BenchmarkZeroremainderUint64-4	300000000	         4.50 ns/op
BenchmarkDivisionLt-4         	500000000	         3.34 ns/op
ok  	_/home/lubr/go/src/github.com/breml/zeroremainder	8.439s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am aware of the fact that these results are not comparable with the implementation of this calculations in BPF, but the give me a feeling about the dimensions.&lt;/p&gt;

&lt;h2 id=&#34;the-easiest-solution:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;The easiest solution&lt;/h2&gt;

&lt;p&gt;While working on this solution I became aware of an even easier way to do the sampling by evaluating &lt;code&gt;x &amp;lt; maxuint / d&lt;/code&gt;. The part &lt;em&gt;maxuint / d&lt;/em&gt; may be calculated at initialization (like &lt;em&gt;reciprocal(d)&lt;/em&gt;), where &lt;em&gt;maxuint&lt;/em&gt; is the maximum number generated by the random number generator.&lt;/p&gt;

&lt;p&gt;With this solution a simple comparison is enough to determine if a packet should be sampled or not.&lt;/p&gt;

&lt;p&gt;This solution may be used, if the source for the random numbers guarantees for a even distribution of the random numbers throughout the whole range of possible numbers.&lt;/p&gt;

&lt;h2 id=&#34;disclaimer:3eb9f22aaf4c7f13bcbe99f3ca61c6be&#34;&gt;Disclaimer&lt;/h2&gt;

&lt;p&gt;This document is a compilation of observations and empirical studies of the described algorithm and by no means a formal proof.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gogitignore</title>
      <link>https://breml.github.io/blog/2015/10/06/gogitignore/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://breml.github.io/blog/2015/10/06/gogitignore/</guid>
      <description>

&lt;p&gt;The other day I extended one of my go (golang) project with some new main packages resulting in new commands. After building the project with &lt;code&gt;go build&lt;/code&gt; the resulting executables are placed in the respective directories within the project. While updating the git repository I found it cumbersome to add all the new executables to the .gitignore-file. On linux there is unfortunately now easy way to exclude all executables within a project with a single line in .gitignore.&lt;/p&gt;

&lt;p&gt;With go it is easily predictable how the resulting executables from a main package are named. The directory name, containing a main package, will be used as filename for the new command. Hence I hacked some lines of go code to automatically update the .gitignore file. The result is the &lt;a href=&#34;https://github.com/breml/gogitignore&#34; target=&#34;_blank&#34;&gt;gogitignore&lt;/a&gt;. At the moment it still a bit rough around the edges, but the main idea is already implemented.&lt;/p&gt;

&lt;h2 id=&#34;usage:82ed5a67ff3dec1227a0a5d6b8aae203&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;In the easiest case you may just run &lt;code&gt;gogitignore&lt;/code&gt; in the root directory of your go project. This will add all executables, build from the main packages, automatically as an entry to the .gitignore file in the project root directory. To double check the result gogitignore provides the flag -stdout (or -dryrun).&lt;/p&gt;

&lt;p&gt;For more information about the usage run &lt;code&gt;gogitignore -h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-dir=&amp;quot;.&amp;quot;: destination directory where .gitignore is located and where to traverse directory tree for go programs.
-dryrun=false: dryrun, no changes are made
-exec=false: find all files with executable bit set
-gomain=true: add executables, resulting from building go main packages
-h=false: print usage
-help=false: print usage
-inplace=false: edit .gitignore in place
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>