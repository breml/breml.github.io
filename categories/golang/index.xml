<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on breml's blog</title><link>https://breml.github.io/categories/golang/</link><description>Recent content in Golang on breml's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 28 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://breml.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Seamless Go Code Navigation in Hexagonal Architectures with VS Code</title><link>https://breml.github.io/blog/2025/09/28/seamless-go-code-navigation-in-hexagonal-architectures-with-vs-code/</link><pubDate>Sun, 28 Sep 2025 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2025/09/28/seamless-go-code-navigation-in-hexagonal-architectures-with-vs-code/</guid><description>&lt;p&gt;When working with Go projects that follow a &lt;strong&gt;hexagonal architecture&lt;/strong&gt;, code navigation can quickly become cumbersome. Between interfaces, adapters, mocks, and middlewares, the built-in &lt;strong&gt;Go to Definition&lt;/strong&gt; (&lt;code&gt;F12&lt;/code&gt;) and &lt;strong&gt;Go to Implementations&lt;/strong&gt; (&lt;code&gt;Ctrl+F12&lt;/code&gt;) commands in Visual Studio Code force you to constantly switch mental context and manually pick the correct target.&lt;/p&gt;
&lt;p&gt;This friction gets worse in projects where you generate mocks (e.g. with &lt;a href="https://github.com/vektra/mockery" target="_blank"&gt;mockery&lt;/a&gt;) or wrapper code for logging and metrics. Every interface ends up with several implementations, and the navigation menu is cluttered with entries that are usually not the one you want.&lt;/p&gt;</description></item><item><title>Detect Trojan Source Attack</title><link>https://breml.github.io/blog/2021/12/07/detect-trojan-source-attack/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2021/12/07/detect-trojan-source-attack/</guid><description>&lt;h2 id="what-is-the-trojan-source-attack"&gt;What is the Trojan Source Attack&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://www.trojansource.codes/" target="_blank"&gt;Trojan Source&lt;/a&gt; attack became famous on
November 1st 2021 by the paper &lt;a href="https://www.trojansource.codes/trojan-source.pdf" target="_blank"&gt;Trojan Source: Invisible Vulnerabilities&lt;/a&gt;
published by &lt;a href="https://github.com/nickboucher" target="_blank"&gt;Nicolas Boucher&lt;/a&gt; and &lt;a href="https://www.cl.cam.ac.uk/~rja14" target="_blank"&gt;Ross Anderson&lt;/a&gt;
and the then following coverage in the security and IT news sites (e.g. &lt;a href="https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/" target="_blank"&gt;1&lt;/a&gt;, &lt;a href="https://www.schneier.com/blog/archives/2021/11/hiding-vulnerabilities-in-source-code.html" target="_blank"&gt;2&lt;/a&gt;, &lt;a href="https://www.computerweekly.com/news/252508879/Businesses-and-governments-urged-to-take-action-over-Trojan-Source-supply-chain-attacks" target="_blank"&gt;3&lt;/a&gt;, &lt;a href="https://www.zdnet.com/article/this-sneaky-trick-could-allow-attackers-to-hide-invisible-vulnerabilities-in-code/" target="_blank"&gt;4&lt;/a&gt;, &lt;a href="https://www.theregister.com/2021/11/01/trojan_source_language_reversal_unicode/" target="_blank"&gt;5&lt;/a&gt;).
The vulnerability is also listed as &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42574" target="_blank"&gt;CVE-2021-42574&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The core of the attack is to use Unicode control characters to reorder tokens in
source code. These visually reordered tokens can be used to display logic that,
while semantically correct, diverges from the logic presented by the logical
ordering of source code tokens.&lt;/p&gt;</description></item><item><title>Embed CA Root Certificates in Go Programs</title><link>https://breml.github.io/blog/2021/01/17/embed-ca-root-certificates-in-go-programs/</link><pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2021/01/17/embed-ca-root-certificates-in-go-programs/</guid><description>&lt;h2 id="abstract"&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Package &lt;a href="https://github.com/breml/rootcerts" target="_blank"&gt;rootcerts&lt;/a&gt; provides an embedded copy of the
&lt;a href="https://wiki.mozilla.org/CA/Included_Certificates" target="_blank"&gt;Mozilla Included CA Certificate List&lt;/a&gt;, more specifically the
&lt;a href="https://ccadb-public.secure.force.com/mozilla/IncludedRootsPEMTxt?TrustBitsInclude=Websites" target="_blank"&gt;PEM of Root Certificates in Mozilla&amp;rsquo;s Root Store with the Websites (TLS/SSL) Trust Bit Enabled&lt;/a&gt;.
If this package is imported anywhere in the program and the &lt;a href="https://golang.org/pkg/crypto/x509/" target="_blank"&gt;crypto/x509&lt;/a&gt; package cannot find the system certificate
pool, it will use the embedded certificates instead.&lt;/p&gt;
&lt;h2 id="background"&gt;Background&lt;/h2&gt;
&lt;p&gt;In my professional work as well as in my private projects I often deploy Go programs as containers. Be it to run them
in the cloud, in K8s or on your local machine. It is pretty common knowledge, how Go programs can be shipped in very
light containers built from &lt;a href="https://docs.docker.com/develop/develop-images/baseimages/" target="_blank"&gt;scratch&lt;/a&gt;
(e.g. &lt;a href="https://sebest.github.io/post/create-a-small-docker-image-for-a-golang-binary/" target="_blank"&gt;Create a small Docker image for a GoLang binary&lt;/a&gt;).&lt;/p&gt;</description></item><item><title>Using MongoDB Backend Service with Go App in the Swisscom App Cloud</title><link>https://breml.github.io/blog/2015/12/22/using-mongodb-backend-service-with-go-app-in-the-swisscom-app-cloud/</link><pubDate>Tue, 22 Dec 2015 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2015/12/22/using-mongodb-backend-service-with-go-app-in-the-swisscom-app-cloud/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In my &lt;a href="https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/"&gt;last post&lt;/a&gt; I described how to create and deploy an app, written with the Google &lt;a href="https://golang.org" target="_blank"&gt;Go&lt;/a&gt; language, to the &lt;a href="http://developer.swisscom.com/" target="_blank"&gt;Swisscom Application Cloud&lt;/a&gt;. This post is a follow up, in which I would like to share some of the learnings, I discovered while extending the &lt;a href="https://github.com/breml/appcloud/tree/helloworld" target="_blank"&gt;Hello World&lt;/a&gt; app, following the ideas for the &lt;a href="https://ict.swisscom.ch/2015/12/move-with-your-mongodb-node-js-into-the-cloud/" target="_blank"&gt;node.js example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This blog post is not a detailed step by step tutorial, but rather points out the in my opinion important steps to understand how to get a Go app running in the App Cloud with a MongoDB backend. I strongly suggest to read the above linked blog posts as well, as they help to get a better overall understanding.&lt;br&gt;
The full working example could be found in my &lt;a href="https://github.com/breml/appcloud" target="_blank"&gt;Github repository&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Deploy a Go Web App to the Swisscom Application Cloud</title><link>https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/</link><pubDate>Thu, 17 Dec 2015 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2015/12/17/deploy-a-go-web-app-to-the-swisscom-application-cloud/</guid><description>&lt;p&gt;Inspired by the &lt;a href="https://ict.swisscom.ch/2015/11/push-your-first-node-js-app-into-the-cloud/" target="_blank"&gt;this blog post&lt;/a&gt; about the deployment of a &lt;a href="https://nodejs.org" target="_blank"&gt;node.js&lt;/a&gt; example app to the &lt;a href="http://developer.swisscom.com/" target="_blank"&gt;Swisscom Application Cloud&lt;/a&gt;, I decided to test the Swisscom Application Cloud my self with a similar app, written in Google &lt;a href="https://golang.org" target="_blank"&gt;Go&lt;/a&gt; language.&lt;/p&gt;
&lt;p&gt;This blog should take you through the essential steps on a Linux based system to push your own Go based app to a &lt;a href="https://www.cloudfoundry.org" target="_blank"&gt;Cloud Foundry&lt;/a&gt; based app cloud, for example the one from Swisscom.&lt;/p&gt;
&lt;h2 id="preparations"&gt;Preparations&lt;/h2&gt;
&lt;h3 id="go-development-environment"&gt;Go development environment&lt;/h3&gt;
&lt;p&gt;I assume you already have a prepared Go development environment. Otherwise I suggest you to start with the &lt;a href="https://golang.org/doc/install" target="_blank"&gt;Getting Started&lt;/a&gt; manual.&lt;/p&gt;</description></item><item><title>Dividable without remainder</title><link>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</link><pubDate>Thu, 22 Oct 2015 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2015/10/22/dividable-without-remainder/</guid><description>&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;h3 id="problem"&gt;Problem&lt;/h3&gt;
&lt;p&gt;For a &amp;ldquo;1 in n sampling&amp;rdquo; problem I was looking for a fast way to determine, if a value &lt;em&gt;x&lt;/em&gt; (random number) is dividable by a previously known divisor &lt;em&gt;d&lt;/em&gt; (sampling rate) without remainder. So the algorithm has to result with &lt;em&gt;true&lt;/em&gt; in &lt;em&gt;1&lt;/em&gt; of &lt;em&gt;d&lt;/em&gt; cases, otherwise with &lt;em&gt;false&lt;/em&gt;. &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;d&lt;/em&gt; are both unsigned integers, in my case 32 bit long. Since the algorithm will be used for sampling and &lt;em&gt;x&lt;/em&gt; is produced by a random number generator (see below: Motivation), a slight inaccuracy (&amp;lt; 0.01%) may be tolerable. The usual range for &lt;em&gt;d&lt;/em&gt; will be whole numbers between 1 and 2000, based on the recommendations for &lt;a href="http://blog.sflow.com/2009/06/sampling-rates.html" target="_blank"&gt;sFlow sampling rates&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>gogitignore</title><link>https://breml.github.io/blog/2015/10/06/gogitignore/</link><pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate><guid>https://breml.github.io/blog/2015/10/06/gogitignore/</guid><description>&lt;p&gt;The other day I extended one of my go (golang) project with some new main packages resulting in new commands. After building the project with &lt;code&gt;go build&lt;/code&gt; the resulting executables are placed in the respective directories within the project. While updating the git repository I found it cumbersome to add all the new executables to the .gitignore-file. On linux there is unfortunately now easy way to exclude all executables within a project with a single line in .gitignore.&lt;/p&gt;</description></item></channel></rss>