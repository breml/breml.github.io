<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><link href=http://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Dividable without remainder &#183;</title><meta name=description content="Fast way to find out if a value is dividable by a dividend without remainder for the special use case of 1 in n sampling."><meta name=keywords content="division,remainder,golang,bpf,sampling,modulo"><link rel=stylesheet href=https://breml.github.io/css/poole.css><link rel=stylesheet href=https://breml.github.io/css/hyde.css><link rel=stylesheet href=https://breml.github.io/css/poole-overrides.css><link rel=stylesheet href=https://breml.github.io/css/hyde-overrides.css><link rel=stylesheet href=https://breml.github.io/css/hyde-x.css><link rel=stylesheet href=https://breml.github.io/css/breml.css><link rel=stylesheet href=https://breml.github.io/css/highlight/sunburst.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://breml.github.io/touch-icon-144-precomposed.png><link href=https://breml.github.io/favicon.png rel=icon></head><body class=theme-base-0d><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://breml.github.io/><img src="https://www.gravatar.com/avatar/ffc66df1e22b19865762dc6dc8129ae8?s=200" alt=gravatar><h1></h1></a><p class=lead>my thoughts about&mldr;</p></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=https://breml.github.io/>Blog</a></li><li class=sidebar-nav-item><a href=https://breml.github.io/about/>About</a></li><li class=sidebar-nav-item><a href=https://breml.github.io/links/>Links</a></li></ul><ul class=sidebar-nav><li class=sidebar-nav-item><a href=https://github.com/breml target=_blank><i class="fa fa-github-square fa-3x"></i></a>
<a href=https://www.linkedin.com/in/lucas-bremgartner-96b477 target=_blank><i class="fa fa-linkedin-square fa-3x"></i></a>
<a href=https://www.xing.com/profile/Lucas_Bremgartner target=_blank><i class="fa fa-xing-square fa-3x"></i></a>
<a href type=application/rss+xml target=_blank><i class="fa fa-rss-square fa-3x"></i></a></li></ul><p>Categories:<br><a class=label href=/categories/bpf>bpf</a>
<a class=label href=/categories/elasticsearch>elasticsearch</a>
<a class=label href=/categories/git>git</a>
<a class=label href=/categories/gogitignore>gogitignore</a>
<a class=label href=/categories/golang>golang</a>
<a class=label href=/categories/sflow>sflow</a></p><p>Copyright &copy; 2025 <a href=https://breml.github.io/license/>License</a></p></div></div><div class="content container"><div class=post><h1>Dividable without remainder</h1><span class=post-date>Oct 22, 2015<br><a class=label href=https://breml.github.io/categories/golang>golang</a><a class=label href=https://breml.github.io/categories/bpf>bpf</a><a class=label href=https://breml.github.io/categories/sflow>sflow</a></span><h2 id=summary>Summary</h2><h3 id=problem>Problem</h3><p>For a &ldquo;1 in n sampling&rdquo; problem I was looking for a fast way to determine, if a value <em>x</em> (random number) is dividable by a previously known divisor <em>d</em> (sampling rate) without remainder. So the algorithm has to result with <em>true</em> in <em>1</em> of <em>d</em> cases, otherwise with <em>false</em>. <em>x</em> and <em>d</em> are both unsigned integers, in my case 32 bit long. Since the algorithm will be used for sampling and <em>x</em> is produced by a random number generator (see below: Motivation), a slight inaccuracy (&lt; 0.01%) may be tolerable. The usual range for <em>d</em> will be whole numbers between 1 and 2000, based on the recommendations for <a href=http://blog.sflow.com/2009/06/sampling-rates.html target=_blank>sFlow sampling rates</a>.</p><h3 id=tldr-solution>tl;dr Solution</h3><p>The obvious solution of course is to use the modulo operation: <code>x % d == 0</code>. In my special case, the modulo operation is not available, and I therefore had to look for an alternative (for details see: Motivation).</p><p>The proposed solution only works with positive (unsigned) values.<br><em>d = 0</em> is not allowed (division by 0); for <em>d = 1</em>, the result is always true.</p><p>If <em>d</em> is a power of 2 (e.g. 4, 8, 16), the result is determined with <code>x & (d - 1) == 0</code>. If true, there is no remainder.</p><p>For all other cases, the following calculation is performed:<br><code>x * reciprocal(d) &lt; reciprocal(d)</code><br>The reciprocal function is defined as:<br><code>reciprocal(d) = maxuint / d + 1</code><br>where the division is an integer division, where the result is round down.<br><em>maxuint</em> is the maximum unsigned integer value of the used data type, in my case 32 bit (<em>maxuint = 2^32 - 1 = 4294967295</em>).</p><p>The check, if <em>d</em> is a power of 2 and the calculation of <em>reciprocal(d)</em> is performed only once at initialization, because the sampling-rate is constant during the whole sampling process.</p><p>For <em>x</em> in 0 to <em>maxuint</em> and <em>d</em> from 1 to 10000 (inclusive) the proposed algorithm returns in 9988 cases the same count of return value = <em>true</em> (and respectively <em>false</em>) as the exact method <code>x % d == 0</code>. In the other 12 cases, the difference of the counts of return value = <em>true</em> is 1, which leads to an inaccuracy below 0.001%.</p><p>These results are verified by a small program of mine, called <a href=https://github.com/breml/zeroremainder target=_blank>zeroremainder</a> available at Github.</p><h3 id=bottom-line>Bottom Line</h3><p>The proposed algorithm is usable for the use case in question, as the difference of the results compared to the exact method, using the modulo operation, is marginal (below 0.001%).</p><h2 id=motivation>Motivation</h2><p>I am working on a tool, to sample network packets at arbitrary sampling rate (normally between 1 and 2000), as proposed by <a href=http://www.sflow.org target=_blank>sFlow</a>). My implementation is based on <a href=https://github.com/google/gopacket target=_blank>gopacket</a>, which uses libpcap, the same library used by <a href=http://www.tcpdump.org/ target=_blank>tcpdump</a>. One of my approaches for the sampling of the packages is based on <a href=https://www.kernel.org/doc/Documentation/networking/filter.txt target=_blank>BPF (Berkeley Packet Filter)</a>, which allows to filter the captured packets in the kernel. The assumption is that filtering in kernel mode should be faster, because there are less context switches and memory copy operations necessary. BPF allows to call the <em>prandom</em> interface of the kernel to get a random uint32 number. One way to decide, if the current packet should be sampled, is to use the <a href=https://en.wikipedia.org/wiki/Modulo_operation target=_blank>modulo</a> operation; random number modulo sampling rate. If the remainder is 0, the packet is sampled, otherwise the packet is ignored.</p><p>Although BPF assembler does provide a modulo instruction, I do not want to use this instruction because of two reasons:</p><ol><li>The modulo BPF instruction is not supported with libpcap &lt; 1.6.0</li><li>Unsigned integer division (and therefore modulo) is one of the slowest operations on a modern microprocessor (see benchmark results below)</li></ol><h2 id=inspiration>Inspiration</h2><p>While searching the web for possible solutions, which could be implemented easily in assembler, I stumbled over <a href=https://courses.engr.illinois.edu/ece390/books/artofasm/CH09/CH09-6.html#HEADING6-39 target=_blank>Division Without DIV and IDIV</a> and the concept of magic numbers (<a href=http://stackoverflow.com/a/2661840 target=_blank>Stackoverflow - Most optimized way to calculate modulus in C</a>, <a href=http://www.hackersdelight.org/magic.htm target=_blank>Magic number generator</a>, <a href=http://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html target=_blank>Labor of Division</a>) which replaces division by a multiplication with a magic number and a binary shift operation.</p><p>Inspired by this ideas I started to experiment with reciprocal, magic numbers and overflow of unsigned integers.</p><h2 id=solution>Solution</h2><h3 id=preconditions>Preconditions</h3><ul><li>We only work with unsigned integers, where the <em>size</em> of the integer is a multiple of 8 (bits), normally one of 8, 16, 32, 64 (depending on data type and architecture)</li><li><em>maxuint</em> is defined as: <code>maxuint = 2^size - 1</code></li><li>The divisor <em>d</em> must not be <em>0</em> (would lead to division by 0 error)</li><li>If <em>d</em> is <em>1</em>, no calculation is performed, the result is always <em>true</em></li><li>The dividend <em>x</em> may be any number in the range from <em>0</em> to <em>maxuint</em></li></ul><h3 id=d-being-a-power-of-2><strong>d</strong> being a power of 2</h3><p>This part of the solution is straightforward. If <em>d</em> is a power of 2 (e.g. 4, 8, 16), the modulo could by determined with a simple <em>and</em> operation, <code>x & (d - 1) == 0</code>. The result of a bitwise <em>and</em>-operation of <em>x</em> and <em>d - 1</em> is the remainder. Therefore if the result is 0, there is no remainder and the equation is <em>true</em>.</p><h3 id=multiply-by-reciprocal>Multiply by reciprocal</h3><p>For all other cases (<em>d</em> not being a power of 2), the basic idea is, to perform a multiplication of <em>x</em> and the reciprocal of <em>d</em>, calculated on the base of <em>maxuint</em>, the maximum integer value of respective data type or architecture (e.g. 32 bit), and use the <em>free</em> wrap around modulo operation of the integer overflow. The integer overflow is described in <a href=https://en.wikipedia.org/wiki/Integer_overflow target=_blank>Wikipedia - Integer overflow</a> as follows:</p><blockquote><p>Since an arithmetic operation may produce a result larger than the maximum representable value, a potential error condition may result. In the C programming language, signed integer overflow causes undefined behavior, while unsigned integer overflow causes the number to be reduced modulo a power of two, meaning that unsigned integers &ldquo;wrap around&rdquo; on overflow.</p></blockquote><p>First we handle some special cases:</p><ul><li>If <em>x == 0</em> the result is always <em>true</em></li><li>If <em>0 &lt; x &lt; d</em> no calculation is performed as the result has to be false</li></ul><p>The elimination of these special cases ensures that a wrap around modulo operation is always performed.</p><p>For the remaining cases (<em>x > d</em>) the following calculation is performed to decide if a packet should be sampled or not:<br><code>x * reciprocal(d) &lt; reciprocal(d)</code>.</p><p>The used reciprocal is calculated as rounded up division of <em>maxuint</em> and <em>d</em>, the division being an integer division, where the result is round down):<br><code>reciprocal(d) = maxuint / d + 1</code></p><p>One of the first question I asked my self about this equation was, why has <em>x * reciprocal(d)</em> to be smaller than <em>reciprocal(d)</em>? To explain this, let&rsquo;s have a look at an example with <em>d</em> being a power of 2. We know, if <em>d</em> is a power of 2, there is a simpler approach to determine, if a <em>x</em> is dividable by <em>d</em> without remainder, by using the bitwise <em>and</em>-operation described above.<br>Nevertheless we may use the proposed algorithm. In this case <em>x * reciprocal(d)</em> will always result to <em>0</em>, if <em>x</em> is dividable by <em>d</em> without remainder. This works because in this case <em>reciprocal(d)</em> results in the effective reciprocal value of d, without rounding error. For all other <em>d</em>, not being a power of 2, <em>reciprocal(d)</em> is always a rounded value, with <em>0 &lt; error &lt; 1</em>.<br>The <em>error</em> may be calculated as follows:<br><code>reciprocal(d) - 2^size / d</code></p><p>This rounding error is the reason, why <em>x * reciprocal(d)</em> does not equal to <em>0</em> if <code>x % d = 0</code>. The higher <em>x</em>, the higher the accumulated <em>error</em> becomes, as the <em>error</em> is multiplied by <em>x</em> as well. Now it becomes clear, there is a point where the accumulated <em>error</em> even exceeds <em>reciprocal(d)</em>, which leads to the situation, where <code>x * reciprocal(d) &lt; reciprocal(d)</code> does not provide the same result as <code>x % d == 0</code>.</p><p>With <code>(2^size / d) / error</code> (integer division) the highest <em>x</em> may be calculated, where the proposed algorithm still provides the same result as <code>x % d = 0</code>. Unfortunately this buys us nothing, because in my scenario <em>x</em> may be any number between <em>0</em> and <em>maxuint</em>. So the next question arises, what happens there or a little bit bolder: does it matter? The short answer is: no, for my use case it does not matter. Why?</p><p>We could understand the proposed algorithm <code>x * reciprocal(d) &lt; reciprocal(d)</code> as a kind of sliding window with the size of <em>d</em>. Because we can not exactly represent the reciprocal of <em>d</em> as whole number, the sliding window is a little bit bigger than <em>d</em>. This leads to a difference between the proposed algorithm and the exact calculation, but the proposed algorithm still fulfills the requirement of selecting approximately every nth element (respectively every <em>d</em>th).</p><h3 id=applied-verification>Applied verification</h3><p>The verify the above statements, I wrote a small program, called <a href=https://github.com/breml/zeroremainder target=_blank>zeroremainder</a> available at Github.</p><p>This program allows to compare the results of the proposed algorithm with the result of the exact method (modulo operation) and calculate the difference of the results.</p><p>As I am primarily interested in the results on 32 bit data types and for divisors between 1 and 2000, my applied verification was focused on these parameters, while the <em>zeroremainder</em> test program does allow to check other number ranges as well.</p><h4 id=results>Results</h4><p>I ran <code>zeroremainder</code> on my 4 core i5 2.67 GHz for about 60 hours, using 100% CPU, to fully calculate the divisors from 2 to 10000 (inclusive) with dividends from 0 to 2^32-1.</p><p>Executed command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>zeroremainder -outputalldivisors -dividendend=0xffffffff -divisorend=10000 &gt; 0_to_0xffffffff_2_to_10000_alldivisors.txt
</span></span></code></pre></div><p>The results of these calculations are:</p><ul><li>The proposed algorithm returns in 9988 cases the same count of return value = <em>true</em> (and respectively <em>false</em>) as the exact method <code>x % d == 0</code>.</li><li>In the other 12 cases (divisors: 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369), the difference of the counts of return value = <em>true</em> is exactly 1, which leads to an inaccuracy below 0.001%.</li></ul><p>For easier verification of the results I sorted these by divisor and added a column with an exact value for the difference between the proposed algorithm and the modulo operation as a percent value as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>cat 0_to_0xffffffff_2_to_10000_alldivisors.txt | sort -n -k 2 | awk &#39; {print $0 &#34; Difference exact (%): &#34; sprintf(&#34;%.16f&#34;, 100-100/$8*$5)}&#39; &gt; 0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt
</span></span></code></pre></div><p>You may download these results as compressed bz2 archive <a href=/downloads/0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2>0_to_0xffffffff_2_to_10000_alldivisors_sorted_exact.txt.bz2</a>.</p><h4 id=benchmarks>Benchmarks</h4><p>To get a feeling about the performance difference of the different algorithms I implemented a small go benchmark.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ go test -bench=.
</span></span><span style=display:flex><span>testing: warning: no tests to run
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>BenchmarkDivisionMod-4                100000000                11.1 ns/op
</span></span><span style=display:flex><span>BenchmarkDivisionPow2-4               300000000                 4.21 ns/op
</span></span><span style=display:flex><span>BenchmarkZeroremainderUint32-4        300000000                 4.46 ns/op
</span></span><span style=display:flex><span>BenchmarkZeroremainderUint64-4        300000000                 4.50 ns/op
</span></span><span style=display:flex><span>BenchmarkDivisionLt-4                 500000000                 3.34 ns/op
</span></span><span style=display:flex><span>ok          /home/lubr/go/src/github.com/breml/zeroremainder    8.439s
</span></span></code></pre></div><p>I am aware of the fact that these results are not comparable with the implementation of this calculations in BPF, but the give me a feeling about the dimensions.</p><h2 id=the-easiest-solution>The easiest solution</h2><p>While working on this solution I became aware of an even easier way to do the sampling by evaluating <code>x &lt; maxuint / d</code>. The part <em>maxuint / d</em> may be calculated at initialization (like <em>reciprocal(d)</em>), where <em>maxuint</em> is the maximum number generated by the random number generator.</p><p>With this solution a simple comparison is enough to determine if a packet should be sampled or not.</p><p>This solution may be used, if the source for the random numbers guarantees for a even distribution of the random numbers throughout the whole range of possible numbers.</p><h2 id=disclaimer>Disclaimer</h2><p>This document is a compilation of observations and empirical studies of the described algorithm and by no means a formal proof.</p></div></div><script src=https://breml.github.io/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><script>var _gaq=[["_setAccount","UA-68498959-1"],["_trackPageview"]];(function(e,t){var n=e.createElement(t),s=e.getElementsByTagName(t)[0];n.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js",s.parentNode.insertBefore(n,s)})(document,"script")</script></body></html>